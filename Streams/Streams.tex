% $Author$
% $Date$
% $Revision$

% HISTORY:
% 2007-03-30 - Cassou splits of Streams from Collection chapter
% 2007-07-05 - Cassou partial draft complete?
% 2007-08-02 - Stef pass
% 2007-08-16 - Cassou continues
% 2007-08-21 - Oscar edit
% 2007-08-21 - Cassou review
% 2009-07-07 - Oscar migrate to Pharo; fixed broken tests

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	\renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi
%=================================================================
\chapter{ストリーム}\chalabel{streams}

%\ew{Streams are presented as a way to navigate collection. From my point of view, stream are important not to navigate collection, but to produce/consume data:
%(a)	memory constraint. Data can not hold into memory and must be processed in a stream fashion, e.g: encryption
%(b)	blocking IO. A stream is a nice abstraction to deal with, and the stream manages internally data availability, buffering, etc. to simplify the consumption/production of data
%Only few streams have random access capability.}

\clsindexmain{ストリーム}

ストリームはコレクション、ファイル、ネットワークストリームのような
連続する要素に対する反復処理に用いられます。
ストリームは読み込み可能か、書き込み可能か、もしくはその両方です。
読み込みまたは書き込みは常にストリームの現在位置に対して相対的です。
ストリームはコレクションに簡単に変換可能ですし、その逆も同様です。

%\lr{"Streams can easily be converted into collections." I wouldn't say it like this, because it is not true for all streams (infinite streams). According to Kent Beck we should only talk about conversion when the same protocol is supported. Collections and Streams do not support the same protocol. (p. 249)}


%=============================================================
\section{二続きの要素}

ストリーミングを理解する良いたとえは以下のようなものです。
ストリームはふたつの「要素の並び」として表現することができます。
すなわち過去の要素の並びと未来の要素の並びです。
ストリームはこの二つの間に位置します。
Smalltalkのストリームに対する全ての操作はこの考えによるので、このモデルを理解しておくのは大切です。
このような理由で、ほとんどの\clsind{Stream}クラスは\clsind{PositionableStream}のサブクラスになっています\figref{_abcde}は5個の文字を含むストリームを表しています。このストリームはその初期位置にあります。\ie 過去には一つの要素もありません。\mthind{PositionableStream}{reset}メッセージによりこの位置に戻ることができます。



\begin{figure}[ht]
\centerline{\includegraphics[scale=0.5]{_abcdeStef}}
\caption{最初のストリームの位置.}
\figlabel{_abcde}
\vspace{.2in}
\end{figure}

要素の読み込みは概念的に、未来の要素列の先頭を取り除き、それを過去の要素列の最後に付け加えることを意味します。
\ct{next}メッセージを使って一つの要素を読むと、ストリームの状態は\figref{a_bcde}に示されているようになります。

\begin{figure}[ht]
\centerline{\includegraphics[scale=0.5]{a_bcdeStef}}
\caption{\ct{next}メソッドを実行したあとの同じストリーム： 文字 \ct{a} は 「過去」 ですが \ct{b}, \ct{c}, \ct{d}, \ct{e} は 「未来」です.}
\figlabel{a_bcde}
\vspace{.2in}
\end{figure}

要素の書き込みは未来の先頭要素を新しいものに置き換えて過去に移動させることを意味します。\figref{ax_cde}は\mthind{Stream}{nextPut:} \ct{anElement}メッセージを使って同じ要素を\ct{x}で書き換えた状態を示しています。


\begin{figure}[ht]
\centerline{\includegraphics[scale=0.5]{ax_cdeStef}}
\caption{\ct{x}を書き込んだ直後のストリーム.}
\figlabel{ax_cde}
\vspace{.2in}
\end{figure}

%=============================================================
\section{ストリーム対コレクション}

コレクションのプロトコルは要素の格納、除去と列挙の手段を提供しますが、それらが合成されることは許されていません。
例を挙げると、\clsind{OrderedCollection}の要素を\ct{do:}メソッドによって処理する場合、
\ct{do:}のブロック内で要素の追加と削除はできません。
あるいは、コレクションのプロトコルには二つのコレクションを同時に反復処理し、片方は前進させて
もう片方をそうしないように選ぶような方法を提供していません。
このような処理には走査用の添字またはコレクション自身の外部に保存された
位置のリファレンスが必要になります。
これこそ\clsind{ReadStream},  \clsind{WriteStream} そして \clsind{ReadWriteStream}の役割です。



これら三つのクラスはコレクションではなく、 \emph{ストリームに}定義されています。
例を挙げると、次のコードはインターバルのストリームを作り、それから二つの要素を読み込みます。


\needlines{5}
\begin{code}{@TEST |r|}
r := ReadStream on: (1 to: 1000).
r next.   --> 1
r next.   --> 2
r atEnd.--> false
\end{code}

\ct{WriteStream}はコレクションにデータを書き込むことができます。


\begin{code}{@TEST |w|}
w := WriteStream on: (String new: 5).
w nextPut: $a.
w nextPut: $b.
w contents. -->  'ab'
\end{code}

読み込みと書き込みの両方のプロトコルを提供する\ct{ReadWriteStream}を作ることもできます。

\ct{WriteStream}と\ct{ReadWriteStream}の主な問題は、\pharo では配列と文字列しか
サポートしていないことです。
これは、Nileと名付けられた新しいライブラリーの開発で変わりつつありますが、
今のところそれ以外のコレクションに対する操作はエラーになります。

\needlines{3}
\begin{code}{}
w := WriteStream on: (OrderedCollection new: 20).
w nextPut: 12. -->  エラー
\end{code}

ストリームはコレクションに対してのみ有効ではなく、ファイルやソケットにも使えます。
次の例は\ct{test.txt}というファイルを作成し、改行で分離された2つの文字列を書き込み、ファイルを閉じます。

\needlines{3}
\begin{code}{}
StandardFileStream
  fileNamed: 'test.txt'
  do: [:str | str
                nextPutAll: '123';
                cr;
                nextPutAll: 'abcd'].
\end{code}
\cmindex{FileStream class}{fileNamed:do:}

次の章ではプロトコルについてさらに詳しく解説します。

%=============================================================
\section{ストリームによるコレクションの操作}

ストリームはコレクションの要素を扱うのにとても便利で、コレクションの要素の読み込みと書き込みに使われます。
これからコレクションに対するストリームの特徴を探っていきます。


%-----------------------------------------------------------------
\subsection{コレクションを読み取る}

このセクションではコレクションの読み込みの特徴について見ていきます。
コレクションの読み込みにストリームを使うことは、本質的にはコレクションへのポインタを提供することになります。
ポインタは読み込みによって前進し、また希望する場所へ自由に移動させることができます。
コレクションの要素を読み込むのには\clsindmain{ReadStream}クラスを使います。

コレクションから一つ以上の要素を読み取るには\mthind{ReadStream}{next}と\mthind{ReadStream}{next:}メソッドを使います。

\begin{code}{@TEST |stream|}
stream := ReadStream on: #(1 (a b c) false).
stream next. -->   1
stream next. -->   #(#a #b #c)
stream next. -->   false
\end{code}
\cmindex{PositionableStream class}{on:}

\begin{code}{@TEST |stream|}
stream := ReadStream on: 'abcdef'.
stream next: 0. -->   ''
stream next: 1. -->   'a'
stream next: 3. -->   'bcd'
stream next: 2. -->   'ef'
\end{code}

\mthind{PositionableStream}{peek}メッセージはストリームの次の要素が
何であるかを、ポインタを進ませないで知りたいときに使われます。

\begin{code}{@TEST |stream negative number|}
stream := ReadStream on: '-143'.
negative := (stream peek = $-).    "読み取ることなく最初の要素を調べる"
negative. --> true
negative ifTrue: [stream next].       "マイナスの文字を無視する"
number := stream upToEnd.
number. --> '143'
\end{code}
\noindent

このコードは、ストリーム中の数の符合をブール変数\ct{negative}に設定し、絶対値を\ct{number}に設定します。
\mthind{ReadStream}{upToEnd}メソッドは現在の位置から最後までのストリームの全てを返し、
ストリームのポインタを最後に設定します。このコードは、引数と同じ時は先に進み、
異なるときは進まない\mthind{PositionableStream}{peekFor:}メソッドを使うことで単純化できます。


\begin{code}{@TEST |stream negative number|}
stream := '-143' readStream.
(stream peekFor: $-) --> true
stream upToEnd         --> '143'
\end{code}
\noindent

\ct{peekFor:}メソッドはまた、引数と要素が等しいかを示す真偽値を返します。

上のコードの例からストリームを作る新しい方法に気付いたと思います。
一連のコレクションに対して単に\mthind{SequenceableCollection}{readStream}メッセージを送ることで、
そのコレクションからストリームを作ることができます。

\paragraph{位置決め} 
ストリームのポインタを位置決めするメソッドがあります。
もしインデックスがあるなら\mthind{PositionableStream}{position:}メソッドで直接そこへ移動できます。
\mthind{PositionableStream}{position}メソッドで現在位置を求めることができます。
ストリームは要素と要素の間を示しているのであって、要素そのものを指しているわけではないことを覚えておいて下さい。
インデックスはストリームの先頭が0になります。


\figref{ab_cde}に描かれたストリームの状態を次のコードで得ることができます。


\begin{code}{@TEST |stream|}
stream := 'abcde' readStream.
stream position: 2.
stream peek --> $c
\end{code}

\begin{figure}[h!t]
\centerline{\includegraphics[scale=0.5]{ab_cdeStef}}
\caption{2番目の位置にあるストリーム}
\figlabel{ab_cde}
\vspace{.2in}
\end{figure}


ストリームの先頭か最後に移動する場合はそれぞれ\mthind{PositionableStream}{reset}メソッド、
\mthind{PositionableStream}{setToEnd}メソッドを使います。
\mthind{PositionableStream}{skip:}と\mthind{PositionableStream}{skipTo:}メソッドは現在位置を基準として前に進む場合に使います。
\ct{skip:}メソッドは引数に数を取ることができ、その数の要素を飛ばします。
一方、\ct{skipTo:}メソッドは与えられた引数と同じ要素が見つかるまでストリームの要素を飛ばしていきます。
そのときの位置は、見つかった要素の後ろになることに注意して下さい。

\begin{code}{@TEST |stream|}
stream := 'abcdef' readStream.
stream next.        --> $a    "ストリームはaの真後ろに位置している"
stream skip: 3.                           "dの後ろに位置している"
stream position.  -->   4
stream skip: -2.                          "bの後ろに位置している"
stream position.  --> 2
stream reset.
stream position.  --> 0
stream skipTo: $e.                      "ストリームはeの後ろに移った"
stream next.        --> $f
stream contents. --> 'abcdef'
\end{code}

ご覧のように\ct{e}の文字は飛ばされています。

\mthind{PositionableStream}{contents}メソッドは常にストリーム全体のコピーを返します。

\paragraph{テスト}現在のストリームの状態をテストするためのメソッドがあります。
\mthind{PositionableStream}{atEnd}メソッドはこれ以上読める要素がない場合のみtrueを返します。
\mthind{PositionableStream}{isEmpty}メソッドはコレクションに全く要素がない場合のみtrueを返します。

二つのソートされたコレクションを引数としてこれらのコレクションを結合、ソートし別のコレクションにするアルゴリズムを
\ct{atEnd}メソッドを使って実装する例を示します。

\needlines{4}
\begin{code}{@TEST |stream1 stream2 result|}
stream1 := #(1 4 9 11 12 13) readStream.
stream2 := #(1 2 3 4 5 10 13 14 15) readStream.

"変数resultにはソートされたコレクションが入る."
result := OrderedCollection new.
[stream1 atEnd not & stream2 atEnd not]
  whileTrue: [stream1 peek < stream2 peek
    "両方のストリームのもっとも小さな要素を取り除き、それらをresultに加える."
    ifTrue: [result add: stream1 next]
    ifFalse: [result add: stream2 next]].
"二つのストリームのどちらかは終端にきていないだろう.残っている全てをコピーする."
result
  addAll: stream1 upToEnd;
  addAll: stream2 upToEnd.

result. -->   an OrderedCollection(1 1 2 3 4 4 5 9 10 11 12 13 13 14 15)
\end{code}

%-----------------------------------------------------------------
\subsection{コレクションへの書き込み}

\ct{ReadStream}を使ってコレクションの要素をどのように反復して読み取るかについては既に見てきました。
次に、\clsindmain{WriteStream}{}を使ってコレクションを作成する方法について学びましょう。


コレクションの様々な場所にたくさんのデータを加えるとき、\ct{WriteStream}は便利です。
次の例のように、静的部分と動的部分からなる文字列を生成するときにもしばしば用いられます。


\begin{code}{NB: can't be tested due to the changing number of classes}
stream := String new writeStream.
stream
  nextPutAll: 'This Smalltalk image contains: ';
  print: Smalltalk allClasses size;
  nextPutAll: ' classes.';
  cr;
  nextPutAll: 'This is really a lot.'.

stream contents. --> 'This Smalltalk image contains: 2322 classes.
This is really a lot.'
\end{code}

この方法は、例えば\ct{printOn:}メソッドの異なる実装にも使えます。
ストリームの内容だけにしか興味がない場合、これはもっと単純で効果的なストリームの作成法です。

\begin{code}{@TEST |string|}
string := String streamContents:
		[:stream |
			stream
                 print: #(1 2 3);
                 space;
                 nextPutAll: 'size';
                 space;
                 nextPut: $=;
                 space;
                 print: 3.	].
string. -->   '#(1 2 3) size = 3'
\end{code}

\mthind{SequenceableCollection class}{streamContents:} \seclabel{streamContents}メソッドは
コレクションと、そのコレクションより成るストリームを作ります。
それからパラメータとして与えたブロックをそのストリームに対して実行します。
ブロックが終了すると\ct{streamContents:}メソッドはコレクションの中身を返します。

次のような状況に合わせた\ct{WriteStream}メソッドがあります。

\begin{description}
\item[\lct{nextPut:}] パラメータをストリームに加えるとき。
\item[\lct{nextPutAll:}] パラメータとして与えたコレクションの要素をそれぞれストリームに追加するとき。
\item[\lct{print:}] ストリームに可読表示手段を追加する。
	\cmindex{Stream}{print:}
\end{description}

\mthind{WriteStream}{space}、\mthind{WriteStream}{tab}、\mthind{WriteStream}{cr} 
などの異なる種類の文字を表示するのに便利なメソッドもあります。
\mthind{WriteStream}{ensureASpace}は、ストリームの最後の文字がスペースでない場合には追加し、
最後がスペースをあることを保証します。

\paragraph{連結について}

\ct{WriteStream}の\mthind{WriteStream}{nextPut:}メソッド、\mthind{WriteStream}{nextPutAll:}メソッドは多くの場合、
文字を連結する一番良い方法になります。
カンマ演算子(\ct{,})による結合はあまり効率的ではありません。

\index{Collection!comma operator}

\begin{code}{}
[| temp |
  temp := String new.
  (1 to: 100000)
    do: [:i | temp := temp, i asString, ' ']] timeToRun --> 115176 "(milliseconds)"

[| temp |
  temp := WriteStream on: String new.
  (1 to: 100000)
    do: [:i | temp nextPutAll: i asString; space].
  temp contents] timeToRun --> 1262 "(milliseconds)"
\end{code}

カンマ演算子は、レシーバと引数を連結した新たな文字列を作成するのでどちらも
コピーしなければなりません。これがストリームの方がカンマ演算子より効果的であることの理由です。
もし、同じレシーバに対してカンマ演算子で連結を繰り返すと、
連結する毎に文字列が長くなり、
コピーすべき文字数は指数関数的に増えてしまいます。
またこの方法はメモリー上に回収されなければならないゴミをたくさん残します。
カンマ演算子の代わりにストリームを使うのはよく知られている最適化方法です。
実際は\mthind{SequenceableCollection class}{streamContents:}メソッド（\pageref{sec:streamContents}参照）
がこれを手伝ってくれます。


\begin{code}{}
String streamContents: [ :tempStream |
  (1 to: 100000)
       do: [:i | tempStream nextPutAll: i asString; space]] 
\end{code}

%-----------------------------------------------------------------
\subsection{読み込みと書き込みを同時に行う}

ストリームを使うことでコレクションに対して同時に読み込みと書き込みを行うことができます。ウェブブラウザーの
前進・後退ボタンの動作を管理する\ct{History}クラスを作りたいという状況を考えてみましょう。
履歴は\ref{fig:emptyStream}から\ref{fig:page4}のような動作をします。


\begin{figure}[!ht]
\centerline{\includegraphics[scale=0.5]{emptyStef}}
\caption{新しいので履歴は空です。ブラウザーには何も表示されていません。}
\figlabel{emptyStream}
\vspace{.2in}
\end{figure}

\begin{figure}[!ht]
\centerline{\includegraphics[scale=0.5]{page1Stef}}
\caption{ユーザーはページ1を開きます。}
\figlabel{page1}
\vspace{.2in}
\end{figure}

\begin{figure}[!ht]
\centerline{\includegraphics[scale=0.5]{page2Stef}}
\caption{ユーザーはページ2へのリンクをクリックします。}
\figlabel{page2}
\vspace{.2in}
\end{figure}

\begin{figure}[!ht]
\centerline{\includegraphics[scale=0.5]{page3Stef}}
\caption{ユーザーはページ3へのリンクをクリックします。}
\figlabel{page3}
\vspace{.2in}
\end{figure}

\begin{figure}[!ht]
\centerline{\includegraphics[scale=0.5]{page2_Stef}}
\caption{ユーザーは戻るボタンをクリックします。今、再びページ2を見ています。}
\figlabel{page2_}
\vspace{.2in}
\end{figure}

\begin{figure}[!ht]
\centerline{\includegraphics[scale=0.5]{page1_Stef}}
\caption{ユーザーは更に戻るボタンをクリックします。ページ1が表示されています。}
\figlabel{page1_}
\vspace{.2in}
\end{figure}

\begin{figure}[!ht]
\centerline{\includegraphics[scale=0.5]{page4Stef}}
\caption{1ページからユーザーは4ページへのリンクをクリックしました。ページ2、ページ3の履歴はなくなります。}
\figlabel{page4}
\vspace{.2in}
\end{figure}

この振る舞いは\clsind{ReadWriteStream}を使うことで実装できます。

\needlines{6}
\begin{code}{}
Object subclass: #History
  instanceVariableNames: 'stream'
  classVariableNames: ''
  poolDictionaries: ''
  category: 'PBE-Streams'

History>>initialize
    super initialize.
    stream := ReadWriteStream on: Array new.
\end{code}

ストリームを持つ新しいクラスを定義しました。このストリームは\ct{initialize}メソッドで作られます。
ここまで特にも難しいことはありません。

次に、前進と後進のメソッドが必要になります。

\begin{code}{}
History>>goBackward
  self canGoBackward ifFalse: [self error: 'Already on the first element'].
  stream skip: -2.
  ^ stream next.

History>>goForward
  self canGoForward ifFalse: [self error: 'Already on the last element'].
  ^ stream next
\end{code}

ここまでのコードはとても単純明快です。
次に、ユーザーがリンクをクリックしたときに動作する\ct{goTo:}メソッドに取りかかりましょう。
たとえば次のようなコードが思いつくかも知れません。

\begin{code}{}
History>>goTo: aPage
    stream nextPut: aPage.
\end{code}

しかし、これでは不十分です。ユーザーがリンクをクリックしたとき、履歴上では進めるページがないはずだからです。
つまり、前進ボタンは無効になってなければいけません。
これを実現するもっともシンプルな方法は、履歴の最後を指している要素の後ろに\ct{nil}を書き込むことです。


\begin{code}{}
History>>goTo: anObject
  stream nextPut: anObject.
  stream nextPut: nil.
  stream back.
\end{code}

さらに、少なくとも\ct{canGoBackward}メソッドと\ct{canGoForward}メソッドが実装されなければいけません。

ストリームは常に二つの要素の間に位置しています。
後退するためには今の位置より前に２つのページがあるはずです。
（ひとつは現在のページ、もうひとつは戻りたいページ）

\begin{code}{}
History>>canGoBackward
  ^ stream position > 1

History>>canGoForward
  ^ stream atEnd not and: [stream peek notNil]
\end{code}

ストリームの中身を確認できるメソッドを追加します。

\begin{code}{}
History>>contents
  ^ stream contents
\end{code}

これで履歴が狙い通りに動きます。

\begin{code}{}
History new
	goTo: #page1;
	goTo: #page2;
	goTo: #page3;
	goBackward;
	goBackward;
	goTo: #page4;
	contents --> #(#page1 #page4 nil nil)
\end{code}

%=============================================================
\section{ファイルアクセスにストリームを使う}

コレクションの要素に対してどのようにストリームを使うかをこれまで見てきました。
ハードディスクのファイルに対しても同じようにストリームを使うことができます。
ファイルに対してのストリームは一度作成するとコレクションに対してのストリームとほとんど変わりません。
同じプロトコルでストリームの読み込み、書き込み、位置の移動ができます。
大きな違いはストリームの作成にあります。
これからいくつか異なるファイルストリームの作成方法を見ていきましょう。


%-----------------------------------------------------------------
\subsection{ファイルストリームを作成する}

\seclabel{creat-file-stre}

ファイルストリームを作るには\clsindmain{FileStream}クラスが提供する
次のインスタンス作成メソッドのどれかを使います。

\begin{description}

\item[\lct{fileNamed:}] 与えられた名前のファイルを読み込みと書き込みのために開きます。
  もしファイルが既に存在していたら、その内容は変更したり置き換えられたりしますが、ファイルを閉じるときに切り捨てられません。
  もし、ファイル名にディレクトリー部分が明示されていない場合、デフォルトディレクトリーにファイルは作成されます。
  \cmindex{FileStream class}{fileNamed:}
  
\item[\lct{newFileNamed:}] 与えられた名前の新しいファイルを作り、そのファイルに書き込むためのストリームを返します。
  もしファイルが既に存在していた場合はユーザーに対してどうするか尋ねます。
  \cmindex{FileStream class}{newFileNamed:}
  
\item[\lct{forceNewFileNamed:}] 与えられた名前のファイルを作成し、そのファイルに書き込むためのストリームを返します。
  もしファイルが既に存在していた場合、そのファイルを確認なしに削除したあとに新しいファイルを作成します。
  \cmindex{FileStream class}{forceNewFileNamed:}

\item[\lct{oldFileNamed:}] 与えられた名前の既にあるファイルを読み込みと書き込みのために開きます。
  もしファイルが既に存在していたら、その内容は変更したり置き換えられたりしますが、ファイルを閉じるときに切り捨てられません。
  もし、ファイル名にディレクトリー部分が明示されていない場合、デフォルトディレクトリーにファイルは作成されます。
  \cmindex{FileStream class}{oldFileNamed:}

\item[\lct{readOnlyFileNamed:}] 与えられた名前の既存のファイルを読み込みのために開きます。
  \cmindex{FileStream class}{readOnlyFileNamed:}

\end{description}

ファイルをストリームで開くたびに、必ず閉じなければならないことを覚えておいて下さい。
これには\mthind{FileStream}{close}メソッドを使います。


\begin{code}{@TEST |stream|}
stream := FileStream forceNewFileNamed: 'test.txt'.
stream
    nextPutAll: 'This text is written in a file named ';
    print: stream localName.
stream close.

stream := FileStream readOnlyFileNamed: 'test.txt'.
stream contents. --> 'This text is written in a file named ''test.txt'''
stream close.
\end{code}


\mthind{FileStream}{localName}メソッドはファイルの一番最後の内容を返します。
\mthind{StandardFileStream}{fullName}メソッドでファイルのフルパスを得ることができます。


そのうち、ファイルストリームを手動で閉じることは面倒な上にエラーの元になることに気付くでしょう。
ストリームに対して内容をセットするブロックを評価した後、自動的に
閉じる\mthind{FileStream class}{forceNewFileNamed:do:}:メソッドを\ct{FileStream}クラスが提供しているのはそのためです。


\begin{code}{@TEST |string|}
FileStream
    forceNewFileNamed: 'test.txt'
    do: [:stream |
        stream
            nextPutAll: 'This text is written in a file named ';
            print: stream localName].
string := FileStream
            readOnlyFileNamed: 'test.txt'
            do: [:stream | stream contents].
string --> 'This text is written in a file named ''test.txt'''
\end{code}

ブロックを引数にとるストリーム作成のメソッドは、まずファイルに対してのストリームを作成し、
次に引数のブロックを実行し、最後にストリームを閉じます。
これらのメソッドはブロックの返すもの、つまり最後のブロック表現の値を返します。
前の例でこれは、ファイルの中身を得てそれを変数\ct{string}に入れるところで使われています。

%-----------------------------------------------------------------
\subsection{バイナリーストリーム}

\seclabel{binary-streams}

デフォルトでストリームは文字の読み込みと書き込み可能なテキストベースで作成されます。
もしストリームがバイナリーでなければいけない場合は、\mthind{FileStream}{binary}メッセージを送る必要があります。


もし、ストリームがバイナリーモードの場合、0から255(1バイト)の数値を書き込むことしかできません。
２つ以上の数値を同時に書き込むのに使いたい場合\ct{nextPutAll:}メソッドを使い、\clsind{ByteArray}を引数として渡す必要があります。

\begin{code}{@TEST}
FileStream
  forceNewFileNamed: 'test.bin'
  do: [:stream |
          stream
            binary;
            nextPutAll: #(145 250 139 98) asByteArray].

FileStream
  readOnlyFileNamed: 'test.bin'
  do: [:stream |
          stream binary.
          stream size.         --> 4
          stream next.         --> 145
          stream upToEnd. --> #[250 139 98]
      ].
\end{code}

次の例は「test.pgm」（portable graymap file format）と言う名前の画像ファイルを作成する例です。
作成したファイルはお気に入りのドロープログラムで開くことができます。


% The following does not assert anything, but @TEST is used to ensure
% that no error is thrown.
\begin{code}{@TEST}
FileStream
  forceNewFileNamed: 'test.pgm' 
  do: [:stream |
	stream
		nextPutAll: 'P5'; cr;
		nextPutAll: '4 4'; cr;
		nextPutAll: '255'; cr;
		binary;
		nextPutAll: #(255 0 255 0) asByteArray;
		nextPutAll: #(0 255 0 255) asByteArray;
		nextPutAll: #(255 0 255 0) asByteArray;
		nextPutAll: #(0 255 0 255) asByteArray
	]
\end{code}

これは\figref{checkerboard4x4}のような4x4のチェッカーボード（市松模様）を作ります。

\begin{figure}[!ht]
\centerline{\includegraphics[width=0.25\textwidth]{checkerboard4x4}}
\caption{バイナリーストリームで描くことができる4x4のチェッカーボード（市松模様）}
\figlabel{checkerboard4x4}
\vspace{.2in}
\end{figure}

%=============================================================
\section{章のまとめ}

ストリームは連続した要素を追加的に読み取る、あるいは書き込む場合に、
コレクションよりも良い方法を提供します。
また、ストリームとコレクションを相互に変換する簡単な方法があります。
\begin{itemize}
  \item ストリームは読み込み可能、または書き込み可能、あるいは読み込み・書き込みがともに可能です。
  \item コレクションをストリームに変換する場合、ストリームにコレクションを引数とした「on」メッセージを送ります。\eg \ct{ReadStream on: (1 to: 1000)}または、コレクションに対して\ct{readStream}などのメッセージを送ります。
  \item ストリームをコレクションに変換する場合、\ct{contents}メッセージを送ります。
  \item 大きなコレクションを連結する場合はカンマ演算子を使うよりも、ストリームを作成してから\ct{nextPutAll:}メソッドでコレクションをストリームに追加し、\ct{contents}メソッドを送って結果を取り出す方法が有効です。
  \item ファイルストリームは初期設定では文字型です。\ct{binary}メッセージを送ることで明示的にバイナリーにすることができます。
\end{itemize}

%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================

%-----------------------------------------------------------------

%%% Local Variables: 
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End:
