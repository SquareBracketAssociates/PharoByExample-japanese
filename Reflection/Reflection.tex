% $Author$
% $Date$
% $Revision$

% HISTORY: [see also Metaprogramming2.tex]
% 2007-05-22 - Damien Pollet started (translation from French article by ...?)
% 2008-01-15 - Alex added text
% 2008-12-15 - Oscar revised
% 2009-03-24 - Stef started new chapter (acttalk ... see separate file)
% 2009-06-01 - Oscar started to revise again and add new material
% 2009-06-08 - Lukas -- unsent messages
% 2009-06-15 - Oscar completed revision
% 2009-06-16 _ Stef comments
% 2009-06-17 - Alexandre completed revision
% 2009-06-19 - Lukas comments
% 2009-07-07 - Oscar migrated to Pharo; fixed broken tests
% 2009-08-16 - Oscar indexing and cleaning up loose ends

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	\renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi

%=================================================================
\chapter{リフレクション}\chalabel{reflection}

%\alex{I addressed lukas comments using editorial macros. Please, if you read this, remove this comment and remove the editorial macros, else their purpose is diminished}

\indexmain{リフレクション}
\st はリフレクション可能なプログラミング言語です。
つまり、プログラムは自分自身の実行や構造を「（ランタイムシステムに）反映する」ことができます。
% \lr{not only on execution, also on the static model}
ランタイムシステムの\emphind{メタオブジェクト}が通常のオブジェクトのように\emph{具現化}されているので、メタオブジェクトに問い合わせを行ったり、インスペクトして内容を見られます。
\st のメタオブジェクトには、クラス、メタクラス、メソッド辞書、コンパイル済みメソッド、実行時スタックなどがあります。
このようなリフレクションは\emphind{イントロスペクション}とも呼ばれ、多くのモダンなプログラミング言語でサポートされています。

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{reflect}
	\caption{具現化とリフレクション。\figlabel{reflect}} % \lr{not referenced, not sure if I understand it}
\end{figure}

\st では逆の操作も可能で、具現化されたメタオブジェクトを変更して、ランタイムシステムに\emph{反映}させることもできます(\figref{reflect}参照)。
このようなリフレクションは\emph{インターセッション}とも呼ばれ、主に動的なプログラミング言語でサポートされていますが、静的な言語での機能は極めて限られます。

他のプログラム（またはプログラム自身）を操作するプログラムを\emphind{メタプログラム}と呼びます。
リフレクション可能なプログラミング言語は、\ind{イントロスペクション}と\ind{インターセッション}の両方をサポートするべきです。
イントロスペクションとは、言語自身を定義するデータ構造（オブジェクト、クラス、メソッド、実行時スタック）を\emph{検査}できる機能です。
インターセッションとは、そのようなデータ構造を\emph{変更}できる機能です。言い換えると、言語の意味論やプログラムの振る舞いを、プログラム自身が変更できる機能です。
ランタイムシステムのデータ構造を検査・変更することを\emph{構造的リフレクション}と呼び、データ構造の解釈の仕方を変更することを\emphind{振る舞い的リフレクション}と呼びます。

この章では、主にind{構造的リフレクション}を扱います。
例と多数挙げながら、 \st がどのようにイントロスペクションとメタプログラミングをサポートしているのかを探っていきます。

%======================================
\section{イントロスペクション}

インスペクタを使うと、オブジェクトの内容を見たり、インスタンス変数の値を変更したり、オブジェクトにメッセージを送ることもできます。

\dothis{次のコードをワークスペースで評価してみましょう:}
\begin{code}{| w |}
w := Workspace new.
w openLabel: 'My Workspace'.
w inspect
\end{code}

このコードを評価すると、インスペクタとワークスペースがもう一つ開きます。
このインスペクタは新しく開いたワークスペースの内部状態を示しており、左ペインにはインスタンス変数（\ct!dependents!, \ct!contents!, \ct!bindings! など）、右ペインには選択したインスタンス変数の値が表示されます。
\ct!contents!インスタンス変数は、ワークスペースのテキストエリアに表示されている内容を表します。\ct!contents!を選択すると、インスペクタの右ペインには空文字列が表示されます。

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{workspaceInspector}
	\caption{\lct!ワークスペース!をインスペクトしている様子。\figlabel{workspaceInspector}}
\end{figure}

\dothis{この空文字列のところに\ct!'hello'!と入力して、\emph{accept}してみましょう。}
これで\ct!contents!変数の値が変りますが、まだワークスペースウィンドウは変化に気付かないので再描画されません。
ウィンドウを更新させるには、インスペクタの下ペインで\ct!self contentsChanged!を評価します。

%-----------------------------------------------------------------
\subsection{インスタンス変数へのアクセス}

インスペクタはどのように動いているのでしょうか？
\st では、インスタンス変数はすべて保護されています。
この理屈から言えば、クラスが何らかのアクセサメソッドを定義していない限り、他のオブジェクトからインスタンス変数にアクセスさせることはできません。
しかし実際には、インスペクタはアクセサメソッドがなくてもインスタンス変数にアクセスできます。これは\stがリフレクション可能だからです。
\st では、クラスはインスタンス変数を名前または数値の添字で定義します。
インスペクタは、\ct!Object!クラスで定義されているメソッド \lct{instVarAt: \emph{index}} または \lct{instVarNamed: \emph{aString}} を使ってインスタンス変数にアクセスします。数値の添字 \lct{\emph{index}} で位置を指定するか、インスタンス変数名 \lct{\emph{aString}} を指定します。インスタンス変数に新しい値を代入するには、\ct!instVarAt:put:! か \ct!instVarNamed:put:! を使います。
\mthindex{Object}{instVarAt:}
\mthindex{Object}{instVarNamed:}
\mthindex{Object}{instVarAt:put:}
\mthindex{Object}{instVarNamed:put:}

例えば次のコードを評価すると、最初のワークスペースで変数 \ct!w! に束縛されていたオブジェクトの内部状態を変更できます。

\begin{code}{}
w instVarNamed: 'contents' put: 'howdy!'; contentsChanged
\end{code}

\important{\emph{注意:} これらのメソッドは開発ツールを作る分には便利ですが、通常のアプリケーションの開発にはよくありません。リフレクション可能なメソッドはオブジェクトのカプセル化の境界を壊すので、理解も保守も難しいコードを生んでしまいます。}
% \lr{Why? The access does not show up when looking for all readers/writers in the code browser.}

\ct!instVarAt:!と\ct!instVarAt:put:!は\ind{プリミティブメソッド}です。プリミティブメソッドは、バーチャルマシンのプリミティブな操作として実装されています。
これらのメソッドのコードを調べれば、特殊な\ind{プラグマ}構文 \ct!<primitive: N>! （\ct!N!は整数）が見つかるでしょう。
% \lr{actually this is the syntax of pragmas (method annotations), \ct!primitive:! is just a special kind of pragma}

\needlines{5}
\begin{code}{}
Object>>>instVarAt: index 
	"プリミティブ。オブジェクト内の固定長配列で管理されているインスタンス変数を返す。"
	!\textbf{<primitive: 73>}!
	"固定長配列の範囲を超えてアクセスする。"
	^self basicAt: index - self class instSize		
\end{code}

プリミティブに続くコードは、プリミティブが失敗した場合にのみ実行されます。
\ct!instVarAt:!では、存在しないインスタンス変数にアクセスしようとすると、プリミティブに続くコードが実行されます。
こうすれば、プリミティブメソッドが失敗したときにデバッガを起動できます。
プリミティブメソッドのコードは変更できますが、\pharo システムの安定性を脅かしかねないため注意してください。

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{allInstanceVariables}
	\caption{\ct!Workspace!のすべてのインスタンス変数を表示している様子。\figlabel{allInstanceVariables}}
\end{figure}

\figref{allInstanceVariables}は、\ct!Workspace!クラスのインスタンス（\ct!w!）の任意のインスタンス変数を表示する方法を示しています。
\ct!allInstVarNames!メソッドは、与えられたクラスのすべてのインスタンス変数の名前を返します。

同様の方法で、同じ特徴を持つインスタンスを集めることもできます。
例えば\ct!SketchMorph!クラスのインスタンスのうち、\ct!owner!インスタンス変数の内容がワールドモーフであるもの（\ie 現在表示されているすべてのイメージ）を集めてみましょう。次の式を試してみてください。

\begin{code}{}
SketchMorph allInstances select: [:c | (c instVarNamed: 'owner') isWorldMorph]
\end{code}

%-----------------------------------------------------------------
\subsection{インスタンス変数について繰り返し処理する}

\mthindex{Object}{instanceVariableValues}
\ct!instanceVariableValues!メッセージについて調べてみましょう。このメソッドは、すべてのインスタンス変数（継承したものは除く）の値のコレクションを返します。
次に例を示します:
\begin{code}{@TEST}
(1@2) instanceVariableValues --> an OrderedCollection(1 2)
\end{code}

このメソッドは\ct{Object}クラスで次のように実装されています:
\needlines{9}
\begin{code}{}
Object>>>instanceVariableValues
	"レシーバのクラスが定義したインスタンス変数の値を集めたコレクションを返す。"	
	| c |
	c := OrderedCollection new.
	self class superclass instSize + 1
		to: self class instSize
		do: [ :i | c add: (self instVarAt: i)].
	^ c
\end{code}

このメソッドは、レシーバのクラスが定義しているインスタンス変数の添字に基づいて、インスタンス変数の値を集めます。この添字は、スーパークラスで使われている最後の添字の直後の値から始まります。
（\ct!instSize! メソッドは、クラスが定義している名前付きのインスタンス変数の数を返します）。

%-----------------------------------------------------------------
\subsection{クラスやインターフェースへの問い合わせ}

\pharo の開発ツール（コードブラウザ、デバッガ, インスペクタなど）はすべて、これまでに見て来たリフレクション可能な機能を使っています。

もういくつか、開発ツールにとって役立つメッセージを挙げましょう:

\lct{isKindOf: \emph{aClass}}は、レシーバが\lct{\emph{aClass}}や、そのスーパークラスのいずれかのインスタンスであれば真を返します。例:

\begin{code}{@TEST}
1.5 class                     --> Float
1.5 isKindOf: Number --> true
1.5 isKindOf: Integer   --> false
\end{code}
\mthindex{Object}{class}
\mthindex{Object}{isKindOf:}

\lct{respondsTo: \emph{aSymbol}}は、セレクタが\lct{\emph{aSymbol}}であるメソッドをレシーバが持っていれば真を返します。例:

\needlines{3}
\begin{code}{@TEST}
1.5 respondsTo: #floor      --> true    "Numberクラスはfloorを実装しています"
1.5 floor                            --> 1
Exception respondsTo: #, --> true    "例外クラスはグループ化できます"
\end{code}
\mthindex{Object}{respondsTo:}

\important{\emph{警告:}ここで紹介した機能は、開発ツールにとっては便利ですが、普通のアプリケーションには適していません。
オブジェクトが属するクラスや理解できるメッセージを調べようとするのは、設計に問題がある兆候です。カプセル化の原則に反しています。
ただし、開発ツールは普通のアプリケーションではありません。開発ツールはソフトウェアそのものを扱うので、コードの内部を詳細に調べる権利があります。}

%There also exist mechanisms for introspecting on various parts of the run-time system, such as  the process scheduler, the memory manager and so on. For now we will focus on navigating through objects, classes and methods, and we will look more closely at rest of the runtime system in an other chapter.
%\on{let's not mention this if we don't actually write such a chapter!}

%-----------------------------------------------------------------
\subsection{コードメトリクス}

\st のイントロスペクションを使えば、コードメトリクスを簡単に調べられます。使い方を見てみましょう。
コード\ind{メトリクス}では、次のようなコードの特徴を調べます。継承の階層の深さ、直接的・間接的なサブクラスの数、各クラスのメソッドやインスタンス変数の数、クラスで新しく定義されたメソッドやインスタンス変数の数などです。
次に\ct!Morph!クラスのメトリクスをいくらか示します。\ct!Morph!クラスは\pharoのすべてのグラフィカルなオブジェクトのスーパークラスであり、巨大なクラスであり、巨大な継承階層のルートクラスだとわかります。リファクタリングが必要かもしれません！

\mthindex{Behavior}{allSuperclasses}
\mthindex{Behavior}{allSelectors}
\mthindex{Behavior}{allInstVarNames}
\mthindex{Behavior}{selectors}
\mthindex{Behavior}{instVarNames}
\mthindex{Behavior}{subclasses}
\mthindex{Behavior}{allSubclasses}
\mthindex{ClassDescription}{linesOfCode}
\begin{code}{}
Morph allSuperclasses size.  -->       2 "継承階層の深さ"
Morph allSelectors size.        --> 1378 "メソッドの数"
Morph allInstVarNames size. -->      6 "インスタンス変数の数"
Morph selectors size.             -->  998 "Morphで新しく定義されたメソッドの数"
Morph instVarNames size.     -->      6 "Morphで新しく定義されたインスタンス変数の数"
Morph subclasses size.          -->    45 "直接のサブクラスの数"
Morph allSubclasses size.      -->  326 "サブクラスの総数"
Morph linesOfCode.               --> 5968 "総コード行数"
\end{code}

オブジェクト指向言語において最も興味深いメトリクスの一つは、スーパークラスから継承し、拡張したメソッドの数です。
このメトリクスにより、クラスとそのスーパークラスの関係がわかります。
次の節以降では、このような疑問をどう調べていくのかを見ていきます。

%======================================
\section{コードをブラウズする}

\st では、すべてがオブジェクトです。特にクラスもまたオブジェクトであり、インスタンスを操作できる便利な機能を提供します。
これから挙げるメッセージはほとんど\ct{Behavior}で実装されているので、どのクラスも理解できます。

\figref{allInstanceVariables}で見たように、クラスに\ct!#someInstance!メッセージを送ると何らかのインスタンスを得られます。
\mthindex{Behavior}{someInstance}
\begin{code}{@TEST} % Possibly fragile!
Point someInstance --> 0@0
\end{code}

すべてのインスタンスを集めるなら\ct!#allInstances!を、メモリ中にあるインスタンスの数を得るなら\ct!#instanceCount!を使います。

\alex{In a Pharo0.1-10342dev09.96.3, I have "ByteString instanceCount --> 63607"}
\mthindex{Behavior}{allInstances}
\mthindex{Behavior}{instanceCount}
\mthindex{Behavior}{allSubInstances}
\begin{code}{} % Cannot test this
ByteString allInstances        --> #('collection' 'position'  ...)
ByteString instanceCount    --> 104565
String allSubInstances size -->  101675
\end{code}

次の機能はアプリケーションのデバッグに役立ちます。
クラスが持つメソッドから、特定の条件を満たすメソッドのみを抽出できます。

\begin{itemize}
\item \mthind{Behavior}{whichSelectorsAccess:} は、指定したインスタンス変数を読み書きするすべてのメソッドのセレクタを返します。
\item \mthind{Behavior}{whichSelectorsStoreInto:} は、指定したインスタンス変数の値を変更するすべてのメソッドのセレクタを返します。
\item \mthind{Behavior}{whichSelectorsReferTo:} は、指定したメッセージを送るすべてのメソッドのセレクタを返します。
\item \mthind{Behavior}{crossReference} 各メッセージを、そのメッセージを送るメソッドの集合に関連づける % Pharo にこのメソッドは見当たらない？
\end{itemize}

\begin{code}{} % TOO FRAGILE TO TEST
Point whichSelectorsAccess: 'x'    --> #(#'\\' #= #scaleBy: ...)
Point whichSelectorsStoreInto: 'x' --> #(#setX:setY: ...)
Point whichSelectorsReferTo: #+  --> an IdentitySet(#rotateBy:about: ...)
Point crossReference --> an Array(
		an Array('*' an IdentitySet(#rotateBy:about: ...))
		an Array('+' an IdentitySet(#rotateBy:about: ...))
		...)
\end{code}

次のメッセージは継承階層も含めて調べます:

\begin{itemize}
\item \mthind{Behavior}{whichClassIncludesSelector:} 与えられたメッセージを実装しているクラスを返します。
\item \mthind{Behavior}{unreferencedInstanceVariables} レシーバのクラスでもサブクラスでも使われないインスタンス変数をリストにして返します。
\end{itemize}

\begin{code}{@TEST}
Rectangle whichClassIncludesSelector: #inspect --> Object
Rectangle unreferencedInstanceVariables            --> #()
\end{code}

\clsind{SystemNavigation}は、システム内のソースコードのブラウズや問い合わせを行うのに便利なメソッドを持つファサードです。
\ct{SystemNavigation} \mthind{SystemNavigation class}{default}を評価して得られるインスタンスを使ってシステム情報を調べられます。
例えば:

\mthindex{SystemNavigation}{allClassesImplementing:}
\begin{code}{@TEST}
SystemNavigation default allClassesImplementing: #yourself --> {Object}
\end{code}

次のメッセージの説明は不要でしょう:

\mthindex{SystemNavigation}{allSentMessages}
\mthindex{SystemNavigation}{allUnsentMessages}
\mthindex{SystemNavigation}{allUnimplementedCalls}
\begin{code}{}
SystemNavigation default allSentMessages size          --> 24930
SystemNavigation default allUnsentMessages size      --> 6431
SystemNavigation default allUnimplementedCalls size --> 270
\end{code}

中には実装されているのに使われていないメッセージもありますが、必ずしも不要とは限りません。\ct{perform:}を使うなどして、ソースコードに現れない形で送られることもあります。
ただし、送られているのに実装されていないメッセージには問題があります。そのままではメッセージ送信に失敗します。
このようなメッセージは、不完全な実装、廃止されたAPI、ライブラリ不足を示している可能性があります。

\mthindex{SystemNavigation}{allCallsOn:}
\ct!SystemNavigation default allCallsOn: #Point! は、ソースコード中で\ct!Point!をレシーバとして扱っているすべてのメッセージを返します。

以上の機能はすべて、 \pharo のプログラミング環境（特にコードブラウザ）に統合されています。
すでに知っているかもしれませんが、メッセージに関する便利なキーボードショートカットがあります。メッセージの実装者（クラス）を調べるには \short{m} 、メッセージのセンダを調べるには \short{n} が使えます。
このような問い合わせがたくさん\ct{SystemNavigation}クラスの\prot{browsing}プロトコルのメソッドとして実装されていますが、あまり知られていないかもしれません。
例えば、次の式を評価すると\ct{ifTrue:}メッセージを実装しているすべてのメソッドをプログラム的にブラウズできます:
\mthindex{SystemNavigation}{browseAllImplementorsOf:}
\begin{code}{}
SystemNavigation default browseAllImplementorsOf: #ifTrue:
\end{code}

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{implementors}
	\caption{すべての\ct!\#ifTrue:!の実装をブラウズしている様子。\figlabel{implementors}}
\end{figure}

特に便利なメソッドは\ct{browseAllSelect:}と、\lct{browseMethodsWithSourceString:}の二つです。次にシステム中のすべてのメソッドのうち \super 送信を行うものをブラウズする方法を示します。最初の方法は総当たりに近くなりますが、二つ目の方法では検索結果から不要なものを多少減らせます。

\mthindex{SystemNavigation}{browseMethodsWithSourceString:}
\mthindex{SystemNavigation}{browseAllSelect:}
\begin{code}{}
SystemNavigation default browseMethodsWithSourceString: 'super'.
SystemNavigation default browseAllSelect: [:method | method sendsToSuper ].
\end{code}

%======================================
\section{クラス、メソッド辞書、メソッド}

クラスもオブジェクトですから、他のオブジェクトと同様にインスペクト・エクスプロアできます。

\mthindex{Object}{explore}
\dothis{\ct{Point explore}を評価してみましょう。}

\figref{CompiledMethod}では、\ind{エクスプローラ}が\clsind{Point}クラスの構造を示しています。
クラスがメソッドを辞書で持っているのがわかります。この辞書のキーはメソッドのセレクタです。
キーがセレクタ \ct{#*} の値は、逆コンパイルされた\ct!Point>>>*!の\ind{バイトコード}を示しています。

\begin{figure}[ht]\centering
	\includegraphics[width=.5\linewidth]{CompiledMethod}
	\caption{\ct!Point!クラスと\ct!\#*!メソッドのバイトコードをエクスプロアする。\figlabel{CompiledMethod}}
\end{figure}

クラスとメソッドの関係について考えてみましょう。
\figref{MethodsAsObjects}を見ると、クラスとメタクラスのスーパークラス \ct{Behavior} が共通していることがわかります。\ct{Behavior}クラスで定義されている\mthind{Behavior}{new}は、クラスに関するメソッドの中でも特に重要です。
どのクラスもメソッドセレクタと\ind{コンパイル済みメソッド}を関連づけるメソッド辞書を持っています。
コンパイル済みメソッドは自分が所属するクラスを知っており、\figref{CompiledMethod}の\ct{literal5}に所属クラスの情報が含まれています。\ct{literal5}はキーをシンボル\ct{Point}、値を\ct{Point}クラスとするアソシエーションです。

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{MethodsAsObjects}
	\caption{クラス、メソッド辞書、コンパイル済みメソッド\figlabel{MethodsAsObjects}}
\end{figure}

システムに問い合わせる際にクラスとメソッドの関係を利用できます。

例えば、あるクラスのメソッドのうち新しく定義されたもの、つまりスーパークラスのメソッドをオーバーライドしていないものを見つけるには、次のようにクラスから\ind{メソッド辞書}をたどります:
\mthindex{Behavior}{methodDict}
\begin{code}{}
[:aClass| aClass methodDict keys select: [:aMethod |
  (aClass superclass canUnderstand: aMethod) not ]] value: SmallInteger
  --> an IdentitySet(#threeDigitName #printStringBase:nDigits: ...)
\end{code}

コンパイル済みメソッドは、メソッドのバイトコードを表すだけのオブジェクトではありません。
システムに問い合わせを行う便利なメソッドも多く提供しています。
そのうちの一つである\ct{isAbstract}メソッドは、メソッドが抽象メソッド（\ct{subclassResponsibility}を送るかどうか）であれば真を返します。
\ct{isAbstract}メソッドを使うと、任意の抽象クラスのすべての抽象メソッドのみを得られます。
\needlines{4}
\begin{code}{}
[:aClass| aClass methodDict keys select: [:aMethod |
  (aClass>>aMethod) isAbstract ]] value: Number
  --> #(#storeOn:base: #printOn:base: #+ #- #* #/ ...)
\end{code}
このコードでクラスに送っている\ct{>>}メッセージは、引数に渡したセレクタに対応するコンパイル済みメソッドを得るために使われます。

% As a slightly more complex example, we can browse 

継承階層での \super 送信をブラウズするには、もっと複雑な問い合わせを行います。
例えばCollectionクラスのサブクラスで \super 送信を行っているメソッドの一覧をブラウズするなら、次のような問い合わせを行います:
\begin{code}{}
class := Collection.
SystemNavigation default
  browseMessageList: (class withAllSubclasses gather: [:each |
    each methodDict associations
      select: [:assoc | assoc value sendsToSuper]
      thenCollect: [:assoc | MethodReference class: each selector: assoc key]])
  name: 'Supersends of ' , class name , ' and its subclasses'
\end{code}

目的のメソッドを振り分けるために、クラスからメソッド辞書を経由してコンパイル済みメソッドにたどりつく過程に注目してください。
\ct{MethodReference}はコンパイル済みメソッドのための軽量プロキシで、多くのツールで使われています。
\clsmthind{CompiledMethod}{methodReference}はコンパイル済みメソッドへのメソッド参照（\ct{MethodReference}のインスタンス）を返す便利なメソッドです。
\begin{code}{@TEST}
(Object>>#=) methodReference methodSymbol --> #=
\end{code}

%======================================
\section{ブラウザー環境}

\clsind{SystemNavigation}はシステムコードに対してプログラム的に問い合わせたりブラウズする便利な機能を提供しますが、もっとよい方法があります。\pharo に統合されている\ind{リファクタリングブラウザ}を使うと、複雑な問い合わせを対話的にもプログラム的にも送れます。

\lct{Collection}クラス階層のメソッドのうち、メソッド自身と異なるメッセージを \super に送っているメソッドに関心があるとしましょう。
このようなコードは悪いコードの臭いがすると考えられます。 \super 送信を \self 送信に置き換えるべきです（考えてみてください。 \super を使うのはメソッドをオーバーライドするときだけです。継承されたメソッドにアクセスしたいのなら、 \self にメッセージを送れば済みます）

リファクタリングブラウザは、問い合わせを関心のあるクラスやメソッドにエレガントな方法で限定してくれます。

\dothis{\ct{Collection}クラスをブラウザで見てみましょう。
クラス名を\actclick して\menu{refactoring scope>subclasses with}を選択すると、\ct{Collection}クラス階層に限定されたブラウザ環境が開きます。
この限定されたスコープの中で\menu{refactoring scope>super-sends}を選択すると、\ct{Collection}クラス階層のメソッドのうち\super送信を行うすべてのメソッドが列挙された新しいウィンドウが開きます。
この中から任意のメソッドをクリックして、\menu{refactor>code critics}を選んでください。
\menu{Lint checks>Possible bugs>Sends different super message}と選んでゆき、\menu{browse}を\actclick してみましょう（\menu{browse}が選択できなければ、そのメソッドにこのバグはありません）。}

\figref{sendDifferentSuper}では、\ct{Collection}クラス階層にそのようなメソッドが19個あることがわかります。この中には、\ct{super printOn:}を送っている\ct{Collection>>>printNameOn:}も含まれています。
\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{sendDifferentSuper}
	\caption{自身のセレクタとは異なる\super送信を行うメソッドを探す様子。\figlabel{sendDifferentSuper}}
\end{figure}

このブラウザ環境はプログラムからでも用意できます。
例えば、次のコードでは\clsind{Collection}とそのサブクラスを扱う\clsind{BrowserEnvironment}のインスタンスを生成して、そこから\super送信を行うメソッドのみを抽出した結果を表示します。
\needlines{4}
\begin{code}{}
((BrowserEnvironment new forClasses: (Collection withAllSubclasses))
	selectMethods: [:method | method sendsToSuper])
	label: 'Collection methods sending super';
	open.
\end{code}{}

このコードは先に挙げた\ct{SystemNavigation}の使用例と同じ意味ですが、よりコンパクトになっています。

最終的には次のようにして、自身のメソッドセレクタと異なる\super送信を行うメソッドをプログラム的に探せます:
\needlines{6}
\begin{code}{}
((BrowserEnvironment new forClasses: (Collection withAllSubclasses))
	selectMethods: [:method | 
		method sendsToSuper
		and: [(method parseTree superMessages includes: method selector) not]])
	label: 'Collection methods sending different super';
	open
\end{code}
ここではメソッドセレクタと異なる\superメッセージを探すために、各コンパイル済みメソッドの構文木（リファクタリングブラウザが解析したもの）を取得しています。
\ct{RBProgramNode}クラスの\prot{querying}プロトコルを見てみれば、構文木に何を尋ねられるかわかります。

%======================================
\section{実行時コンテキストにアクセスする}

これまで \st のリフレクティブな機能を使ったオブジェクト、クラス、メソッドへの問い合わせやエクスプロアを見てきました。では、実行時環境についてはどうでしょう?

%-----------------------------------------------------------------
\subsection{メソッドコンテキスト}

メソッドを実行する実行時コンテキストはバーチャルマシンが管理しています --- 仮想イメージの中にはないのです！
しかし、\ind{デバッガ}が実行時コンテキストにアクセスできるのは明白です。さらに幸いにも、他のオブジェクトと同様に実行時コンテキストをエクスプロアできます。
どうやっているのでしょう？

実は、デバッガには何の仕掛けもありません。
この秘密は、これまで軽く触れただけだった\pvind{thisContext}という疑似変数にあります。
メソッド中で\ct{thisContext}を参照すると、そのメソッドを実行しているコンテキストが一連の\clsind{MethodContext}オブジェクトとして仮想イメージに登場します。

この仕組みは簡単に実験できます。

\dothis{\ct{Integer>>>factorial}の実装に下線部の式を挿入してしてください:}

\mthindex{Object}{halt}
\begin{code}{}
Integer>>>factorial
	"レシーバーの階乗を返す。"
	self = 0 ifTrue: [!\underline{thisContext explore. self halt.}! ^ 1].
	self > 0 ifTrue: [^ self * (self - 1) factorial].
	self error: 'Not valid for negative integers'
\end{code}

\dothis{\ct{3 factorial}をワークスペースで評価します。\figref{exploringThisContext}のようにデバッガウィンドウとエクスプローラの両方が表示されはずです。}

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{exploringThisContext}
	\caption{\lct{thisContext}をエクスプロアしている様子。\figlabel{exploringThisContext}}
\end{figure}

貧相なデバッガへようこそ！
ここでエクスプロアされたオブジェクトのクラスをブラウズすると（\ie エクスプローラの下のペインで\ct{self browse}を評価すると）、\ct{thisContext}が\lct{MethodContext}のインスタンスであることがわかるでしょう。\ct{sender}の連鎖においても同様です。
% All of these objects have been created dynamically in the image by the \st virtual machine at the point where \ct{thisContext} was referred to in the \ct{factorial} method. \lr{Not actually. In all the currently available VMs the context objects are created with every method activation, no matter if they are accessed using \ct{thisContext} or not.}

\ct{thisContext}は一般的なプログラミングで使うものではありませんが、デバッガのようなツールを実装したり、コールスタックにアクセスするには必要不可欠です。
次の式を評価すると、\ct{thisContext}を使っているメソッドを見つけられます。

\begin{code}{}
SystemNavigation default browseMethodsWithSourceString: 'thisContext'
\end{code}

この結果から、メッセージのセンダの取得が\ct{thisContext}の最も一般的な用途だとわかります。
次に示すコードは典型的な例です:
\begin{code}{}
Object>>>subclassResponsibility
	"このメッセージはサブクラスの振る舞いに関する仕組みを支えています。
	サブクラスはこのメッセージを実装すべきだと忠告します。"

	self error: 'My subclass should have overridden ', thisContext sender selector printString
\end{code}

\st の慣習では、\ct{self subclassResponsibility} を送るメソッドは抽象メソッドとみなされます。
では、\clsmthind{Object}{subclassResponsibility}メソッドはどうやって抽象メソッドが呼ばれたことを示すエラーメッセージを提供するのでしょうか？
答えは簡単。\ct{thisContext}にセンダを尋ねるだけです。

\lr{I think co-routines and continuations should at least mentioned here. Another very practical application that is simple and could be shown here is the ``escaper''. Store the current context into a temp or inst-var \ct{target := thisContext} and jump back to that stack frame at a later point in time using \ct{target return: 123}.}
\sd{lukas maybe we should have another chapter showing such kind of beasts. I would love to read it.
Showing how to use block to build exception and such a kind of point. I think that this chapter should be an introduction may be
we should have a Reflection applied chapter}
\lr{I would love to help writing such a chapter}
%-----------------------------------------------------------------
\subsection{「賢い」ブレークポイント}

\mthindex{Object}{halt}
\st でブレークポイントを設定するには、メソッド内の関心のある箇所で \ct{self halt} を評価するコードを書きます。この式が実行されると\ct{thisContext}が具現化され、ブレークポイントで評価を止めた\ind{デバッガ}のウィンドウが開きます。
残念ですが、システムで集中的に使われるメソッドにブレークポイントを設定すると問題を起きてしまいます。

例えば、\ct{OrderedCollection>>>add:}の実行を解析したいとしましょう。
このメソッド内にブレークポイントを設定すると困ったことになります。

\dothis{\emph{新しい}仮想イメージを用意して、次のブレークポイントを設定します:}
\needlines{3}
\begin{code}{}
OrderedCollection>>>add: newObject
	!\underline{self halt.}!
	^self addLast: newObject
\end{code}

仮想イメージがデバッガウィンドウすら開かずにフリーズしてしまいます！
次の点を理解すれば、問題がはっきりとわかります。 (i) \ct{OrderedCollection>>>add:}はシステムのあちこちで使われているので、変更をアクセプトした途端にブレークポイントで止まります。 (ii) \emph{デバッガ自身}が\ct{add:}メッセージを\ct{OrderedCollection}のインスタンスに送るので、デバッガの表示が邪魔されてしまいます！
このような問題を避けるには、デバッグしたい状況でのみ\emph{停止}する方法が必要です。
その用途にぴったりなのが\clsmthind{Object}{haltIf:}です。

では\ct{add:}を、例えば\ct{OrderedCollectionTest>>>testAdd}のコンテキストから呼ばれたときにだけ停止させたいとしましょう。

\dothis{また新しい仮想イメージを用意して、次のブレークポイントを設定してみましょう:}
\begin{code}{}
OrderedCollection>>>add: newObject
	!\underline{self haltIf: \#testAdd.}!
	^self addLast: newObject
\end{code}

\ct{OrderedCollectionTest}を実行してみましょう。今度はフリーズしません。
（\ct{OrderedCollectionTest}は\scat{CollectionsTests-Sequenceable}カテゴリにあります）

どう動いているのでしょうか？ \clsmthind{Object}{haltIf:}を見てみましょう:
\begin{code}{}
Object>>>haltIf: condition
	| cntxt |
	condition isSymbol ifTrue: [
		"指定されたセレクタ（シンボル）のメソッドがセンダのコールチェーンに含まれる場合のみ停止する"
		cntxt := thisContext.
		[cntxt sender isNil] whileFalse: [
			cntxt := cntxt sender. 
			(cntxt selector = condition) ifTrue: [Halt signal]. ].
		^self.
	].
	...
\end{code}

\ct!haltIf:!は実行時スタックを\ct!thisContext!から遡りながら、呼び出したメソッドの名前が引数と一致するか確認します。
一致したら例外を発生させます。デフォルトの挙動では、この例外を発生させるとデバッガを表示します。

\ct{haltIf:}の引数に真偽値や真偽値を返すブロックを渡してもよいですが、その場合は単純な処理になるので\lct{thisContext}は使われません。

%======================================
\section{理解されないメッセージをインターセプトする}
\seclabel{msgnotunderstood}

ここまでは、 \st のリフレクティブな機能をオブジェクト、クラス、メソッド、実行時スタックに主に問い合わせを行ったりエクスプロアするのに使ってきました。ここからは \st システムの構造に関する知識をどう使ってメッセージをインターセプトするのか、振る舞いを実行時に変えるのかを見ていきます。

オブジェクトはメッセージを受け取ると、まず自身のクラスのメソッド辞書からメッセージに対応するメソッドを探します。
対応するメソッドが見つからなければ、\ct{Object}までクラス階層をたどります。それでも見つからなければ、オブジェクトは\ct{doesNotUnderstand:}の引数にメッセージセレクタとメッセージに渡された引数を与えて\emph{自分自身に送ります}。
\ct{doesNotUnderstand:}の送信に関しても同様にメソッド検索が行われ、\clsmthind{Object}{doesNotUnderstand:}が見つかればデバッガが起動します。

しかし、もし\ct{doesNotUnderstand:}がメソッド検索パスにある\ct{Object}のサブクラスでオーバーライドされていたらどうなるでしょう？
これはある種の非常に動的な振る舞いを実現するのに便利です。\ct{doesNotUnderstand:}をオーバーライドすることで、オブジェクトは理解できないメッセージを理解できるようになり、メッセージに応答する代替手段になります。

このテクニックの最も一般的な応用例は、(1) \ind{軽量プロキシ}の実装と (2) 足りないコードの動的なコンパイルまたはロード、です。

%-----------------------------------------------------------------
\subsection{軽量プロキシ}

最初の例として、既存のオブジェクトのプロキシとして振る舞う「\ind{最小限のオブジェクト}」を紹介します。
このプロキシは固有のメソッドを実質的に持たないので、どんなメッセージが送られても\ct{doesNotUnderstand:}で捕捉されます。このメッセージを実装すれば、プロキシは主体にメッセージを移譲する前に特別な行動を起こせます。

どのように実装できるのかを見てみましょう。\footnote{\pkg{PBE-Reflection}を\url{http://www.squeaksource.com/PharoByExample/}からロードできます}。

\ct{LoggingProxy}を次のように定義します:
\begin{code}{}
ProtoObject subclass: #LoggingProxy
	instanceVariableNames: 'subject invocationCount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PBE-Reflection'
\end{code}
\ct{Object}ではなく\ct{ProtoObject}のサブクラスとして定義していることに注意してください。\ct{Object}からこのプロキシに400個以上のメソッド(!)を継承したくないからです。

\begin{code}{}
Object methodDict size --> 408
\end{code}

このプロキシには二つのインスタンス変数があります。 \ct{subject} はプロキシの実体です。\ct{invocationCount}はプロキシがインターセプトしたメッセージの数です。
二つのインスタンス変数を初期化し、インターセプトしたメッセージの数を返すアクセサを提供します。
初期化時点では、\ct{subject}変数はプロキシオブジェクト自身を指しています。
\begin{code}{}
LoggingProxy>>>initialize
	invocationCount := 0.
	subject := self.
\end{code}

\begin{code}{}
LoggingProxy>>>invocationCount
	^ invocationCount
\end{code}

理解できないすべてのメッセージをインターセプトし、トランスクリプトに表示し、メッセージ数を更新し、メッセージをプロキシの実体へ転送します。

\begin{code}{}
LoggingProxy>>>doesNotUnderstand: aMessage 
	Transcript show: 'performing ', aMessage printString; cr.
	invocationCount := invocationCount + 1.
	^ aMessage sendTo: subject
\end{code}

ここでちょっとした魔法の登場です。
\ct{Point}オブジェクトと\ct{LoggingProxy}オブジェクトを生成し、プロキシに「\ct{Point}オブジェクトになれ（\mthind{ProtoObject}{become:}）」と伝えます。
\seeindex{\ct{become:}}{\ct{ProtoObject>>>become:}}
\begin{code}{}
point := 1@2.
LoggingProxy new !\underline{become:}! point.
\end{code}

これにより、仮想イメージにある\ct{Point}オブジェクトへのすべての参照をプロキシへの参照とスワップします（逆も同様です）。特にプロキシの\ct{subject}インスタンス変数は\ct{Point}オブジェクトを参照することになります！

\begin{code}{}
point invocationCount --> 0
point + (3@4)             --> 4@6
point invocationCount --> 1
\end{code}

この方法でだいたい問題ありませんが、足らない点もあります:
\begin{code}{}
point class --> LoggingProxy
\end{code}
奇妙なことに\ct{class}メソッドは\ct{ProtoObject}で実装されておらず（\ct{Object}で実装されています）、\ct{LoggingProxy}は\ct{Object}を継承していません！
\ct{class}はメッセージとして送られるのではなく、仮想マシンによって直接処理されます。
\footnote{\ct{yourself}も同様に、決して送られません。
レシーバによって仮想マシンが直接解釈する可能性のあるメッセージを次に示します:
\ct{+- < > <= >= = ~= * / \ ==}
\ct{@ bitShift: // bitAnd: bitOr:}
\ct{at: at:put: size}
\ct{next nextPut: atEnd}
\ct{blockCopy: value value: do: new new: x y}
次に示すセレクタは決して送られません。コンパイラが比較とジャンプのバイトコードにインライン展開します:
\ct{ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:}
\ct{and: or:}
\ct{whileFalse: whileTrue: whileFalse whileTrue}
\ct{to:do: to:by:do:}
\ct{caseOf: caseOf:otherwise:}
\ct{ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:}
これらのメッセージを論理値ではないオブジェクトに送っても、きちんと解釈されます。
レシーバが\ct{mustBeBoolean}をオーバーライドするか、\ct{NonBooleanReceiver}例外を捕捉して適切な論理値を返せば実行を継続できます。
}% NB: Notes by Lukas Renggli

このような特別なメッセージ送信を無視するとしても、この方法には克服できない根本的な問題があります。\self送信をインターセプトできません。
\begin{code}{}
point := 1@2.
LoggingProxy new become: point.
point invocationCount --> 0
point rect: (3@4)        --> 1@2 corner: 3@4
point invocationCount --> 1
\end{code}

このプロキシは\ct{rect:}メソッド中の二度の\self送信を数え損ねています:
\begin{code}{}
Point>>>rect: aPoint 
	^ Rectangle  origin: (self min: aPoint) corner: (self max: aPoint)
\end{code}

このテクニックのプロキシを使えばメッセージをインターセプトできますが、プロキシに起因する制限に気をつけてください。
\secref{wrapper}では、メッセージをインターセプトするためのより一般的な方法を見ていきます。

%-----------------------------------------------------------------
\subsection{欠けているメソッドを生成する}

理解されないメッセージのインターセプトの一般的な応用例として、欠けているメソッドの動的なロードまたは生成が挙げられます。
多数のメソッドを持つ巨大なクラスライブラリを考えてみましょう。ライブラリ全体をロードする代わりに各クラスのスタブをロードしてもよいでしょう。スタブはどこを探せばメソッドのソースコードが見つかるのか知っています。スタブは理解できないメッセージをすべて捕捉し、欠けているメソッドを必要に応じて動的にロードします。この処理はいずれ行われなくなり、ロードされたコードはクライアントアプリケーションに最低限必要な量だけ保存されます。

%\on{Stef sez: check ObjectOut -- I looked, but this seems to be very old. Depends on SqueakPage.}

このテクニックのシンプルな応用例を見てみましょう。次に示すクラスは必要に応じてインスタンス変数へのアクセサを自動的に追加します:
% \lr{the last statement should return the result of the message, otherwise you cannot proceed with the debugger} \alex{all redefinition of doesNotUnderstand: includes a return statement. However, I do not see your comment lukas, I tried to insert a 'self halt' in the method, I was able to proceed. I added the return in the function} \lr{Of course it depends on the exact circumstances. If you perform a message on self that returns self it does not matter, but in any other case a forgotten return can introduce strange side effects. There was no return in the listing below, but now there is and the problem is solved.}

\begin{code}{}
DynamicAcccessors>>>doesNotUnderstand: aMessage
	| messageName |
	messageName := aMessage selector asString.
	(self class instVarNames includes: messageName)
		ifTrue: [
			self class compile: messageName, String cr, ' ^ ', messageName.
			^ aMessage sendTo: self ].
	^ super doesNotUnderstand: aMessage
\end{code}
理解できないメッセージはすべてここで捕捉されます。送られたメッセージと同じ名前のインスタンス変数があれば、自身のクラスにアクセサをコンパイルするように依頼します。その後、メッセージをもう一度送信します。

\ct{DynamicAccessors}クラスに（初期化されていない）インスタンス変数\ct{x}があり、\ct{x}のアクセサが定義されていないとしましょう。次の式を評価すると、アクセサが動的に生成されて\ct{x}の値を取得できます:
\needlines{2}
\begin{code}{}
myDA := DynamicAccessors new.
myDA x --> nil
\end{code}

\ct{DynamicAccessors}オブジェクトに最初に\ct{x}メッセージが送られたときに何が起きるか、順に見て行きましょう（\figref{DynamicAccessors}を参照）。

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{DynamicAccessors}
	\caption{アクセサを動的に生成する。\figlabel{DynamicAccessors}}
	% \alex{not sure whether the figure is highly necessary. The code is rather simple and the figure complete to follow in my opinion.}}
	% \on{trust me, it is useful to see all the steps.}
\end{figure}

(1) \ct{x}を\ct{myDA}に送ると (2) メソッドがクラスのメソッド辞書から探索されますが、(3) クラス階層をたどっても見つかりません。(4) 従って\ct{self doesNotUnderstand: #x}がオブジェクトに送り返され、(5) 改めてメソッド探索が行われます。\ct{DynamicAccessors}ではすぐに\ct{doesNotUnderstand:}が見つかり、(6) 文字列\ct{'x ^ x'}をコンパイルするよう依頼します。 (7) \ct{compile}メソッドが探索され、(8) 最終的に\ct{Behavior}クラスで見つかります。(9-10) コンパイル済みメソッドが\ct{DynamicAccessors}のメソッド辞書に追加されます。(11-13) 最後に再び\ct{x}メッセージが再送されますが、今度は対応するメソッドが見つかります。

この方法はインスタンス変数のセッター、その他の決まりきったコード、Visitorパターンのvisitメソッドなどの生成に使えます。

ステップ(13)で使われている\clsmthind{Object}{perform:}に注目してください。このメソッドを使うと、実行時に動的にメッセージを生成して送れます。
\begin{code}{@TEST}
5 perform: #factorial                                             --> 120
6 perform: ('fac', 'torial') asSymbol                       --> 720
4 perform: #max: withArguments: (Array with: 6) --> 6
\end{code}

%======================================
\section{メソッドラッパーとしてのオブジェクト}
\seclabel{wrapper}

これまで見てきたように、\stではコンパイル済みメソッドも通常のオブジェクトです。コンパイル済みメソッドも当然ながら多くのメソッドを持っており、そのメソッドを使って実行時システムに問い合わせを行えます。
少し意外かもしれませんが、\emph{どんな}オブジェクトでもコンパイル済みメソッド役を演じられます。\ct{run:with:in:}といくつかの重要なメッセージに応答すればいいのです。

\dothis{空のクラス\ct{Demo}を定義します。\ct{Demo new answer42}を評価して、いつもの``Message Not Understood''エラーの発生を確認してください。}

普通のオブジェクトを\ct{Demo}クラスのメソッド辞書にインストールします。

\dothis{\lct{Demo methodDict at: \#answer42 put: ObjectsAsMethodsExample new.}を評価し、再び\ct{Demo new answer42}の結果を表示してください。今度は\ct{42}という回答を得られます。}

\clsind{ObjectsAsMethodsExample}クラス定義を調べると次のメソッドが見つかります:
%\alex{I would prefer having return 42 in the run:with:in: method, and not having answer42 defined in ObjectsAsMethodsExample, this could be confusing I imagine}
%\on{ObjectsAsMethodsExample is part of the standard pharo image -- it is not in PBE-Reflection}
\needlines{5}
\begin{code}{}
answer42
	^42

run: oldSelector with: arguments in: aReceiver
	^self perform: oldSelector withArguments: arguments
\end{code}

\ct{Demo}のインスタンスが\ct{answer42}メッセージを受け取るといつも通りにメソッド探索が行われますが、仮想マシンは普通のオブジェクトがコンパイル済みメソッド役を演じようとしていることを検出します。
仮想マシンは\ct{ObjectsAsMethodsExample}オブジェクトに\ct{run:with:in:}メッセージを送ります。このメッセージの引数は最初に送られたメソッドセレクタ、引数、レシーバです。
\ct{ObjectsAsMethodsExample}は\ct{run:with:in:}メソッドを実装しており、メッセージをインターセプトして自身に移譲します。

次のようにすれば、この偽のメソッドを削除できます:
\begin{code}{}
Demo methodDict removeKey: #answer42 ifAbsent: []
\end{code}

\ct{ObjectsAsMethodsExample}をさらに詳しく調べると、スーパークラスが\ct{flushcache}、\ct{methodClass:}、\lct{selector:}のメソッドを定義していることがわかりますが、定義だけで何も実装されていません。これらのメッセージはコンパイル済みメソッドに送られる可能性があるので、コンパイル済みメソッドのふりをするために実装しておく必要があります（\ct{flushcache}はこの中で最も重要なメソッドです。他のメソッドは\clsmthind{Behavior}{addSelector:withMethod:}または\clsmthind{MethodDictionary}{at:put:}でメソッドをインストールする場合に必要になります）。

%-------------------------------------------------------------------------
\subsection{メソッドラッパーをテストカバレッジの評価に使う}

メソッドラッパーはメッセージをインターセプトする有名なテクニックです\cite{Bran98a}。
オリジナルの実装\footnote{http://www.squeaksource.com/MethodWrappers.html}では、メソッドラッパーは\ct{CompiledMethod}のサブクラスのインスタンスです。インストールすると、メソッドラッパーは元のメソッドの起動前後に特別なアクションを実行できます。
アンインストールすると、元のメソッドはメソッド辞書のあるべき位置に戻されます。

Pharoでは\ind{メソッドラッパー}を簡単に実装できます。\ct{CompiledMethod}のサブクラスを作る代わりに\ct{run:with:in:}を実装します。実際、オブジェクトによるメソッドラッパーの、軽量の実装\footnote{http://www.squeaksource.com/ObjectsAsMethodsWrap.html}が存在します。しかし、これを書いている時点では、この実装は、標準のPharoの一部ではありません。

Pharoでは、\ind{メソッドラッパー}は、より簡単に実装できます。\ct{CompiledMethod}のサブクラスを作る代わりに、\ct{run:with:in:}を実装すればいいのです。実際に軽量のメソッドラッパー\footnote{http://www.squeaksource.com/ObjectsAsMethodsWrap.html}が書かれていますが、これを書いている時点ではPharoに組み込まれていません。

ただし、Pharoのテストランナーはこの方法を使ってテストカバレッジを評価しています。
テストランナーがどのように動作するのか見てみましょう。

テストカバレッジの開始点は\clsmthind{TestRunner}{runCoverage}です:
\begin{code}{}
TestRunner>>>runCoverage
	| packages methods |
	... "カバレッジを測定するメソッドを決定する"
	self collectCoverageFor: methods
\end{code}

\clsmthind{TestRunner}{collectCoverageFor:}メソッドはカバレッジを調べるアルゴリズムをわかりやすく示しています:
\begin{code}{}
TestRunner>>>collectCoverageFor: methods
	| wrappers suite |
	wrappers := methods collect: [ :each | TestCoverage on: each ].
	suite := self
		reset;
		suiteAll.
	[ wrappers do: [ :each | each install ].
	  [ self runSuite: suite ] ensure: [ wrappers do: [ :each | each uninstall ] ] ] valueUnpreemptively.
	wrappers := wrappers reject: [ :each | each hasRun ].
	wrappers isEmpty 
		ifTrue: 
			[ UIManager default inform: 'Congratulations. Your tests cover all code under analysis.' ]
		ifFalse: ...
\end{code}
チェックする各メソッドについて1個ずつラッパーが作られ、そして、各ラッパーがインストールされます。
テストが実行され、すべてのラッパーはアンインストールされます。
最後に、テストされなかったメソッドについてのフィードバックが、得られます。

ラッパーそれ自身は、どのように動くのでしょうか?
次の\ct{TestCoverage}ラッパーには、3個のインスタンス変数: \ct{hasRun}、\ct{reference}、\ct{method}があります。
これらは以下のように初期化されます。
\begin{code}{}
TestCoverage class>>>on: aMethodReference
	^ self new initializeOn: aMethodReference

TestCoverage>>>initializeOn: aMethodReference
	hasRun := false.
	reference := aMethodReference.
	method := reference compiledMethod
\end{code}

installメソッドと、uninstallメソッドは、自明な方法で、メソッド辞書を更新します:
\begin{code}{}
TestCoverage>>>install
	reference actualClass methodDictionary
		at: reference methodSymbol
		put: self

TestCoverage>>>uninstall
	reference actualClass methodDictionary
		at: reference methodSymbol
		put: method
\end{code}
\noindent
そして、\ct{run:with:in:}メソッドは、単に、\ct{hasRun}インスタンス変数を更新し、ラッパーをアンインストールし(カバレッジが検証されたから)、もともとのメソッドにメッセージを再送します。
\begin{code}{}
run: aSelector with: anArray in: aReceiver
	self mark; uninstall.
	^ aReceiver withArgs: anArray executeMethod: method

mark
	hasRun := true
\end{code}
(\clsmthind{ProtoObject}{withArgs:executeMethod:}を見てみましょう。そして、メソッド辞書から取り除かれていたメソッドが、どのように呼び出されるか、見てみましょう。)

ただそれだけです。

メソッドラッパーを使えば、あらゆる種類の振る舞いを(それが適切であれば)、通常のメソッドの操作の前かあとに実行させられます。典型的な応用例は、インストゥルメンテーション(メソッドの呼び出しパターンに関する統計を収集すること)、オプションで、事前・事後条件をチェックすること、メモ化(オプションで、メソッドが計算した値をキャッシュすること)です。

%======================================
\section{プラグマ}

\emphind{プラグマ}は、プログラムについてのデータを明記するアノテーション(注釈)ですが、プログラムの実行には関与しません。プラグマは、プラグマがアノテートするメソッドの操作に、直接影響しません。
プラグマには、いくつもの使い道があります、それらは、例えば以下のようなものです:
\begin{itemize}
\item コンパイラーへの情報: \indmain{プラグマ}は、コンパイラがメソッド呼び出しをプリミティブ関数にするのに用いられます。このプリミティブ関数は、仮想マシンか外部プラグインが定義しなければなりません。
\item 実行時処理: いくつかのプラグマは、実行時にこれを検査できます。
\end{itemize}

プラグマが適用可能なのは、プログラムのメソッド宣言においてのみです。メソッドは、1個かそれ以上のプラグマを宣言でき、そしてプラグマは、どのSmalltalkの文よりも先に宣言されなければなりません。各プラグマは、事実上、リテラル引数をともなった静的メッセージ送信です。

この章の前の方でプリミティブを紹介したときに、簡単なプラグマの例を見ました。プリミティブは、プラグマ宣言以上の何物でもありません。
\ct{instVarAt:}メソッドの定義内の\ct{<primitive: 73>}を検討してください。このプラグマのセレクターは、\ct{primitive:}であり、その引数はリテラル値で、\ct{73}です。

コンパイラーはおそらく、プラグマの大口ユーザです。SUnitもまた、アノテーションを活用するツールです。SUnitは、テストユニットからアプリケーションのカバレッジを見積れます。SUnitでは、いくつかのメソッドを、カバレッジから除外したいと思うかもしれません。以下は、\ct!SplitJointTest class!の\ct!documentation!メソッドの場合です:

\begin{code}{}
SplitJointTest class>>>documentation
	<ignoreForCoverage>
	"self showDocumentation"
	
	^ 'This package provides function.... "
\end{code}

単に、メソッドを\ct!<ignoreForCoverage>!プラグマでアノテートするだけで、カバレッジのスコープをコントロールできます。

%Beside the compiler, Lint is a heavy user of pragmas. Lint is a static code analyzer that flags suspicious, non-portable constructs and code that is likely to contain bugs. It may happen that a method needs to be excluded from Lint analysis. This is the case here:

%\begin{code}{}
%MorphObjectOut>>>doesNotUnderstand: aMessage 
%	"Bring in the object, install, then resend aMessage"
%	"Transcript show: thisContext sender selector; cr."
%	"useful for debugging"
%	
%	! \textbf{<lint: 'Unnecessary "= true"' rationale: 'recursionFlag may be nil' author: 'stephane.ducasse'>}!
%	...
%\end{code}	

%One of the pragmas used by Lint to filter out methods is \ct{lint:rationale:author:}.

プラグマは、\clsind{Pragma}のインスタンスであって、ファーストクラスのオブジェクトです。コンパイル済みメソッドは、\mthind{CompiledMethod}{pragmas}メソッドを実装します。\ct!pragmas!メソッドは、プラグマの配列を返します。

\begin{code}{}
(SplitJoinTest class >> #showDocumentation) pragmas.
  --> an Array(<ignoreForCoverage>)
(Float>>#+) pragmas --> an Array(<primitive: 41>)
\end{code}

特定のクエリを定義するメソッドが、クラスから取り出されることがあり得ます。\ct!SplitJoinTest!のクラス側には、\ct!<ignoreForCoverage>!とアノテートされた、いくつかのメソッドがあります:

\begin{code}{@TEST}
Pragma allNamed: #ignoreForCoverage in: SplitJoinTest class  --> an Array(<ignoreForCoverage> <ignoreForCoverage> <ignoreForCoverage>)
\end{code}

\ct{allNamed:in:}の変種が、\ct{Pragma}のクラス側に見付かるでしょう。

プラグマは、どのメソッドの中で、そのプラグマが定義されたか知っていおり(\ct{method}を使えばわかります)、そのメソッドの名前を(\ct{selector})、そのメソッドを含むクラスを(\ct{methodClass})、プラグマの引数の数を(\ct{numArgs})、プラグマに特定の引数リテラルがあるかどうかを(\ct{hasLiteral:}と\ct{hasLiteralSuchThat:})知っています。

\lr{Typically pragmas are performed on an interpreter object that understands the pragma message.}

%======================================
\section{章のまとめ}

リフレクションと言った場合、それは、実行時システムのメタオブジェクトについて、これにクエリを送れたり、これを検査できたり、これを変更さえできたりすることを指します。こうした点で、メタオブジェクトは、普通のオブジェクトと同等です。

\begin{itemize}
\item インスペクターは、\ct{instVarAt:}や、これに関連するメソッドを用いて、オブジェクトの「プライベートな」インスタンス変数にクエリを送ったり、これを変更したりします。
\item 与えられたクラスのすべてのインスタンスを知りたければ、\ct{Behavior>>>allInstances}をそのクラスに送りましょう。
\item \ct{class}、\ct{isKindOf:}、\ct{respondsTo:}\etc メソッドは、メトリクスを収集したり、開発ツールを構築するのには便利ですが、通常のアプリケーションでは、これらは避けるべきです: これらのメソッドはオブジェクトのカプセル化の原則に反し、コードを理解しづらく、保守しづらいものにします。
\item \ct{SystemNavigation}はユーティリティークラスであって、クラス階層をナビゲートし、ブラウズするのに、便利なクエリを備えています。例えば、与えられた文字列をソースコードに含む、すべてのメソッドを見つけ出すには、\ct{SystemNavigation default browseMethodsWithSourceString: 'pharo'.}を使いましょう。(遅いですが、完全な検索方法です!)
\item どの \st のクラスにも、\ct{MethodDictionary}があって、この辞書は、セレクターとコンパイル済みメソッドのインスタンスを対応づけています。コンパイル済みメソッドは、そのクラスを知っています。こうして、両者はお互いを知っていることになります。
\item \ct{MethodReference}は、コンパイル済みメソッドの軽量プロキシーです。\ct{MethodReference}は、追加の簡易メソッドを提供するもので、多くの\st のツールが、この\ct{MethodReference}を使っています。
\item \ct{BrowserEnvironment}、これはリファクタリングブラウザーのインフラの一部ですが、これを使えば、\ct{SystemNavigation}より洗練されたインターフェースを通して、システムにクエリを送れます。これは、クエリの結果が、次の新しいクエリのスコープとして使えるからです。\ct{BrowserEnvironment}では、GUIによるインターフェースとプログラム的なインターフェースの両方が利用できます。
\item \ct{thisContext}は疑似変数です。この疑似変数は、仮想マシンの実行時スタックを具現化したものです。\ct{thisContext}は、主にデバッガーで使われ、スタックに対する会話的なビューを動的に構築するのに使われます。\ct{thisContext}はまた、メッセージのセンダーを動的に特定したい場合に、とりわけ便利です。
\item \ct{haltIf:}を使えば、賢いブレークポイントを設定できます。このとき、メソッドセレクターを、\ct{haltIf:}の引数にします。\ct{haltIf:}は、その引数のシンボルと一致するメソッドが、センダーとして、実行時スタック内に現われたときのみ、停止します。
\item 一般的には、与えられたターゲットに送られるメッセージをインターセプトするには、「最小限のオブジェクト」を使います。最小限のオブジェクトは、ターゲットのプロキシーとして使います。プロキシーで実装するメッセージは、できるだけ少なくします。そして、\ct{doesNotunderstand:}を実装して、すべてのメッセージ送信を捕捉します。こうすれば、いくつかの追加のアクションを実行してから、もともとのターゲットにメッセージを転送できます。
\item プロキシーとそのターゲットのような、ふたつのオブジェクトへの参照を交換するには、\ct{become:}を使いましょう。
\item 注意してください。いくつかのメッセージ、例えば\ct{class}や\ct{yourself}は、決して実際には送られず、代わりに、仮想マシンによって解釈されます。他の、例えば、\ct{+}, \ct{-} and \ct{ifTrue:} も、直接仮想マシンによって解釈されるか、インライン展開されます。このようなことが起こるかどうかは、レシーバーによって異なります。
\item \ct{doesNotUnderstand:}をオーバーライドする、他の典型的な例は、欠けているメソッドの遅延ロードまたは、遅延コンパイルです。
\item \ct{doesNotUnderstand:}は、\self-送信を捕捉できません。
\item オブジェクトをメソッドラッパーとして使えば、より厳密な意味で、メッセージをインターセプトできます。このようなラッパーは、メソッド辞書内の、本来ならコンパイル済みメソッドが格納されるべき場所にインストールされます。メソッドラッパーは、\ct{run:with:in:}を実装しなければなりません。このメッセージは、仮想マシンが、メソッド辞書内で、コンパイル済みメソッドの代わりに普通のオブジェクトを検出したときに送られます。このテクニックは、SUnitテストランナーが、カバレッジデータを集めるのに使われています。
\end{itemize}

%=========================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi
%=========================================================

%Other stuff:
%- anonymous classes (uses compile: and primitiveChangeClassTo:) ???
%- collect direct senders; class collaborations
%- Object primitiveChangeClassTo: become: and becomeForward: (see tests and slides with minimal object example)
%- PointerFinder?
%- anonymous classes (see slides) ?

%Test  Coverage using ObjectsAsMethodsWrap package:
%\begin{code}{}
%category := 'SCGPier'.
%w := (ObjectAsOneTimeMethodWrapper installOnClassCategory: category).
%tr := TestRunner new.
%ToolBuilder open: tr.
%[tr
%	categoryAt: (tr categoryList indexOf: 'SCGPier') put: true;
%	selectAllClasses;
%	runAll.]
%ensure: [[w do: [:each| each uninstall ]] valueUnpreemptively].
%((w select: [:each | each executed not ])
%	collect: [:each | each wrappedClass name, '>>', each selector name ]) explore.
%\end{code}
