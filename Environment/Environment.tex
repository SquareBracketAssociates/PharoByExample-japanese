% $Author$
% $Date$
% $Revision$

% HISTORY:
% 2006-10-24 - Pollet started
% 2006-12-09 - Andrew adds material
% 2007-08-30 - Andrew completes first draft
% 2007-08-31 - Oscar edits
% 2007-09-07 - Stef corrections
% 2007-10-08 - Cassou corrections
% 2010-03-05 - Alexandre minor correction (thanks Ralph Boland)

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
\documentclass[a4paper,10pt,twoside]{book}
\usepackage[
papersize={6.13in,9.21in},
hmargin={.75in,.75in},
vmargin={.75in,1in},
ignoreheadfoot
]{geometry}
\input{../common.tex}
\pagestyle{headings}
\setboolean{lulu}{true}
% --------------------------------------------
% A4:
% \documentclass[a4paper,11pt,twoside]{book}
% \input{../common.tex}
% \usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
\begin{document}
% \renewcommand{\nnbb}[2]{} % Disable editorial comments
\sloppy
\fi
%=================================================================
\chapter{\pharo のプログラミング環境}
\chalabel{env}

% Email 2009-10-21
\hw{The fist paragraph talks about error handling. Maybe it is a good idea to reference point 1.4 for the problems related with error handling. I know that forward references are not good, but changing the order to talk about error codes first is a big change. \\
Just as a comment, in my class of exceptions, I start talking about how to write safe code and talk about error code as a common technique. Then we discuss about the problems of error code handling (as you do later in the chapter) and then I make them think about how to "remove" all that code duplication... the solution then is obviuos, the problem needs to be reified and a object model has to be created to solve the problem... then we talk about whose responsible for what so, processes, contexts and blocks came into play and we deduce the final model together... Anyway, the idea of seen exceptions as a model that replaces error codes makes a lot of sense to them and help them understand exceptions from the conceptual point of view \\
- Section 1.4: it says: "If Smalltalk did provide exception-handling".
I think it should say: "If Smalltalk did NOT provide exception-handling" \\
- Something that is missing but I don't know if it is one goal of the chapter is some words about whose responsible to signal exceptions (the objects at the end of the tree call) and whose responsible to handle exceptions (the objects at the top of the tree call) \\
Section 1.7 sounded to me a little out of order... because you need to talk about defaultAction but you have not talked about how handlers are found yet... I would move this secction to the end, as an example of exception usage \\
- Page 12, point 4: it says: "send it value: E". I think it should say "send TO it value: E". I also would write "value: E" in italics because it makes more clear that you are talking about a message. \\
- Section Nested Exceptions: "Exception handlers are outside of their own scope" For me is confusing... maybe "Exception handlers do not handle exceptions signaled during its evaluation" or something like that?
The first example of Nested Exceptions does:
\ct{result := [[ Error signal ....]}\\
But nowhere before is said what \#on:do: returns... \\
- Section 1.9: Does it make sense to talk about abandon? It is the same as return...
Section 1.10: I would put section 1.10 as part of 1.9. I mean, it is the same from the organization point of view as Retry Execution, etc. \\
- Page 16, second example: ResumableLoader>>readOptionsFrom:aStrem. A the end of the method does "aStream close". I think it should not close the stream, that is responsibility of the one that opened it and passed it as parameter.
Page 16, third example, the "stream close" should be inside an \#ensure: :-) \\
- I would move the Deprication example to a different section. I think it is better to finish with how exception can be handle and then give examples. \\
- About deprication, why is it an exception? why not having a global object to wich one can send the message \#deprecated:on:in: ? my feeling is that there is no need to use exceptions for this... even more, I'm starting to think that they are a bad example of exception usage... \\
- Section 1.11: I would move it inside section 1.9, at the same level as Retry excecution, Returning execution, etc.
Section 1.12: Same as section 1.11. I would put Resending exceptions as part of 1.9
Section 1.13: Same as section 1.11 (does it make sense to have outer? I think it only adds confusion... just a coment) \\
- Page 23: It seems to me that the second example is not doing what it is expected. The handler variable references the doit closure, not the handler. I think it should be:
\ct{| exception handler |
[ exception := thisContext sender at: 1.
1/0 ]
on: Error
do: [ :ex | handler := thisContext ].
{ exception . handler } explore}
I would also suggest to send the message \#at: 1 to the handler \\
- Section 1.16: I don't like the title... Specialized Exceptions or Specific Exceptions ?
I think a good discussion about when to subclass an exception and when to reuse an exception is valuable. Something to help avoid a class explosion of exceptions... That is an interesting problem... \\
}

この章の目的は、\pharo のプログラミング環境を使い、どのようにプログラムを開発するかを示すことです。
既にブラウザを使ってメソッドやクラスをどのように定義するかについて見てきたわけですが、この章ではブラウザのその他の機能について示し、他のいくつかのブラウザについて紹介していきます。

もちろん作ったプログラムが期待したように動作しないのはよくあることです。\pharo には優れたデバッガがあります。最も役立つツールではありますが、最初に使うときは悩むかもしれません。デバッグの手順について説明し、いくつかのデバッガの機能について実演します。

\st 固有の特徴の一つは、プログラミングをしているとき、静止したプログラムテキストの世界ではなく、動いているオブジェクトからなる世界にいるということです。このことにより、プログラミング中に非常に素早いフィードバックを得ることが可能で、このフィードバックによって生産性がより向上します。動いているオブジェクトを見たり、実際に変更したりするために二つのツールがあります。それは\emph{インスペクタ}と\emph{エクスプローラ}です。

ファイルやテキストエディタではなく、動いているオブジェクトからなる世界でプログラミングを行っているため、\st イメージファイルからプログラムを取り出すために、何らかの明示的な作業をしなければいけません。
この作業のための昔からのやり方は、\emph{ファイルアウト}や\emph{チェンジセット}を作ることで、すべての\st の方言でサポートされています。これらは、基本的に他のシステムで読み込めるようにコード化されたテキストファイルです。
\pharo 上でプログラムを取り出すための新しい方法は、サーバー上のバージョン管理されたリポジトリにコードをアップロードすることです。このために、Monticelloと呼ばれるツールを使います。これは特にチームで作業する際に、よりパワフルで効果的な手段となります。
\seeindex{change set}{file, filing out}
\index{file!filing out}

%Finally, you may find a bug in \pharo as you work; we explain how to report bugs, and how to submit bug fixes.
%\ab{Or I would, if I knew how. We should do this, or remove the paragraph.}

%=========================================================
\section{概要}
\seclabel{overview}

\st と現在のグラフィカルインターフェースは一緒に発展してきました。
\st の最初の公開リリースである1983年以前でさえ、\st は独自のグラフィカルな開発環境を備え、すべての\st の開発はその上で行われてきました。
では、\pharo の主なツールを見ていきましょう。

\begin{itemize}
\item{\menu{Browser}(ブラウザ)}は、中心的な開発ツールです。クラスやメソッドの作成、定義、構築を行う際にこのツールを使います。これを使うことですべてのクラスライブラリもブラウズできます。ソースコードを別々のファイルに保存する他の環境とは異なり、\st ではすべてのクラスやメソッドがイメージファイルに含まれます。
\index{browser}

\item{\menu{Message Names}(メッセージネーム)}ツールを使うことにより、特定のセレクタもしくは部分文字列を含んだセレクタを持つすべてのメソッドを探すことができます。(訳注：Pharo 1.4ではFinderツールに統合されており、ドロップダウンメニューでSelectorsを選択することで利用できます)
\index{message name finder}

\item{\menu{Method Finder}(メソッド・ファインダ)}ツールは、メソッドを探すのに役立ちますが、メソッド名と同様に、何を\emph{する}のかによりメソッドを検索します。(訳注：Pharo 1.4ではFinderツールに統合されており、ドロップダウンメニューでExamplesを選択することで利用できます)
\index{method finder}

\item{\menu{Monticello Browser}(Monticelloブラウザ)}は、Monticelloパッケージからコードを読み込んだり、保存したりするための出発点です。

\item{\menu{Process Browser}(プロセスブラウザ)}は、\st 上で実行されているすべてのプロセス(スレッド)を見るのに役立ちます。
\index{process browser}

\item{\menu{Test Runner}}は、SUnitテストを実行、デバッグすることができます。詳細については\charef{SUnit}を参照してください。
\index{Test Runner}
\index{SUnit}

\item{\menu{Transcript}(トランスクリプト)}は、\glbind{Transcript}出力ストリームに対するウィンドウで、\secref{transcript}で既に述べた通り、ログメッセージを書くのに役立ちます。

\item{\menu{Workspace}(ワークスペース)}は入力することができるウィンドウです。
          これはいろいろな目的に使えますが、最もよく使われるのは\st 式を入力して、\menu{do it}で実行することです。
          \ind{workspace}の使い方は\secref{transcript}にも図解されています。
\end{itemize}

\menu{Debugger}(デバッガ)は名前からわかる通り明確な役割を持っています。しかし、他のプログラミング言語のデバッガと比べて、より重要な役割を担っていることに気づくでしょう。\st では\ind{debugger}上で\emph{プログラム}できるのです。デバッガはメニュー画面から起動されるのではなく、たいてい、失敗するテストプログラムを実行したり、\short{\textbf{.}}と入力して起動しているプロセスを中断したり、あるいは、コード中に\lct{self halt}式を挿入したりすることで、起動されます。
\index{process!interrupting}

%=========================================================
\section{ブラウザ}
\seclabel{browser}

\st の歴史と共に、長年にわたり多くの異なるクラスブラウザが開発されてきました。
\pharo では、様々なビューを一つにまとめたブラウザを提供することで、この物語を単純にしました。
\figref{SystemBrowser0}は最初にブラウザを開いたときに表示されるものです。\footnote{もしブラウザが\figref{classBrowser}のように表示されない場合、デフォルトのブラウザを変更する必要があるかもしれないことを思い出してください。\faqref{packagebrowser}参照}\footnote{訳注：\pharo のデフォルトブラウザは何度も変更されています。バージョン1.3では、OBSystemBrowserが使用されており、この章の説明とは異なる場合があります。バージョン1.4ではデフォルトブラウザはSystemBrowserであり、OBSystemBrowserは別途インストールする必要がありました。バージョン1.4 SummerではOBSystemBrowserがデフォルトブラウザになっています}

\begin{figure}[htbp]
   \centering
   \ifluluelse
{\includegraphics[width=\textwidth]{SystemBrowser0} }
{\includegraphics[width=0.7\textwidth]{SystemBrowser0} }
   \caption{ブラウザ}
   \figlabel{SystemBrowser0}
\end{figure}

ブラウザ上部の4つの小さなペインは、システム内メソッドの階層ビューを表しています。これは、NeXTstepの\textit{File Viewer}やMac OS Xの\textit{Finder}のカラムモードといった、ディスク上のファイルを見るためのビューと同様のものです。
左端のペインはクラスの\emph{パッケージ}リストです。そのうちの一つ(例えば\scat{Kernel})を選択すると、すぐ右隣にあるペインにパッケージ中のすべてのクラスが表示されます。
% \on{I adopted the spelling of NeXTstep recommended by wikipedia}

\begin{figure}[htbp]
   \centering
   \ifluluelse
{\includegraphics[width=\textwidth]{SystemBrowser1} }
{\includegraphics[width=.7\textwidth]{SystemBrowser1} }
   \caption{ブラウザで\ct{Model}クラスを選択
   \figlabel{SystemBrowserModel}}
\end{figure}

同様に、左から2番目のペインでクラスの一つ、例えば\menu{Model}(\figref{SystemBrowserModel}参照)を選ぶと、その右隣の3番目のペインにクラスに対して定義された\emph{プロトコル}が表示され、デフォルトで仮想プロトコル\prot{-{}-all-{}-}が選択されます。
プロトコルとはメソッドをカテゴリ化するためのもので、クラスの振る舞いを概念的に首尾一貫して細分化することで、それらを探したり考えたりするのに役立ちます。
左から4つめのペインは、選択したプロトコルで定義されているすべてのメソッド名が表示されます。
ここでメソッド名を選ぶと、そのメソッドのソースコードがブラウザ下部にある大きなペインに表示されます。このペインではソースコードのブラウズや編集、編集後の保存ができます。
ブラウザで\menu{Model}クラス、\protind{dependents}プロトコル、そして\menu{myDependents}を選択していくと、\figref{SystemBrowserMyDependents}のように表示されるはずです。
\protindex{all}
\cmindex{Model}{myDependents}

\begin{figure}[htbp]
   \centering
   \ifluluelse
{\includegraphics[width=\textwidth]{SystemBrowserMyDependents}}
{\includegraphics[width=0.7\textwidth]{SystemBrowserMyDependents}}
   \caption{\ct{Model}クラスの\ct{myDependents}メソッドをブラウザで表示
   \figlabel{SystemBrowserMyDependents}}
\end{figure}

Mac OS X の\emph{Finder}とは違い、ブラウザ上部4つのペインは完全に同じものというわけではありません。
クラスやメソッドは\st 言語の一部であるのに対し、パッケージとプロトコルはそうではなく、これらはブラウザの各ペインに表示すべき情報量を制限するために導入されたものです。例えば、もしプロトコルがなければ、ブラウザは選択したクラスのすべてのメソッドのリストを表示する必要があります。多くのクラスでは、このようなリストは大きすぎて扱うのが不便になってしまいます。
\index{Mac OS X Finder}

このことから、新しいパッケージやプロトコルを作る方法は、新しいクラスやメソッドを作る方法とは異なります。新しいパッケージを作るにはパッケージペインで\actclick し\menu{new package}を選びます。新しいプロトコルを作るにはプロトコルペインで\actclick し\menu{new protocol}を選びます。
ダイアログの中に新しく作ったものの名前を入力すれば完了です。パッケージやプロトコルについては、名前や内容を入力する以外に必要な作業は何もありません。
\index{package!creating}

\begin{figure}[htbp]
   \centering
   \ifluluelse
{\includegraphics[width=\textwidth]{SystemBrowserClassCreation}}
{\includegraphics[width=0.7\textwidth]{SystemBrowserClassCreation}}
   \caption{クラス作成テンプレートをブラウザに表示
   \figlabel{SystemBrowserClassCreation}}
\end{figure}

これとは対照的に、新しいクラスやメソッドを作るには、
実際に何らかの\st コードを書く必要があります。
(左端のペインで)現在選択されているパッケージをクリックすると、
ブラウザ下部のペインにクラス生成のテンプレートが表示されます(\figref{SystemBrowserClassCreation})。
このテンプレートを編集することで、新しいクラスを作ります。
\ct{Object}を作りたいサブクラスの親となる既存のクラス名で置き換え、
\ct{NameOfSubclass}を新しいサブクラス名に置き換えます。
既にわかっているのであれば、インスタンス変数名を入力します。
新しいクラスに対するカテゴリは、デフォルトで現在選択しているパッケージのカテゴリとなりますが、
\footnote{パッケージとカテゴリが正確には同じものではないことを思い出してください。\secref{packages}にてそれらの関係について詳しく見ていきます}必要なら変更することもできます。
既にサブクラス化の元となる既存クラスをブラウザで選択しているのならば、
クラスペインを\actclick し\menu{class templates \ldots \go subclass template}を選択することにより、
ほんの少し初期化が異なる同様のテンプレートを得ることができます。
また、既存のクラス定義でクラス名を新しいものに変えることでもクラス定義を編集できます。
どの場合でも新しい定義をアクセプトすると、
(\ct{#}から始まる名前の)新しいクラスが(つまり対応するメタクラスのインスタンスとして)作られます。
クラスを作ることはそのクラスを参照するグローバル変数を作ることでもあるため、
名前によって既存の全クラスを参照することができるわけです。


\index{class!creation}
\index{browser!defining a class}

新しいクラス名が、(\ie \ct{#}で始まる)\lclsind{シンボル}としてクラスの作ったテンプレートの中に現れる理由や、クラスが作られた後は(\ie \ct{#}のない)識別子としてクラス名を使えば、そのクラスをコードから参照できるようになる理由が理解できたでしょうか?

新しいメソッドを作るプロセスも同様です。最初にメソッドを作りたいクラスを選択し、次にプロトコルを選択します。\figref{SystemBrowserMethodTemplate}のように、ブラウザは編集可能なメソッド作成テンプレートを表示します。
\index{method!creation}
\index{browser!defining a method}

\begin{figure}[htbp]
   \centering
   \ifluluelse
{\includegraphics [width=\textwidth]{SystemBrowserMethodTemplate}}
{\includegraphics[width=0.7\textwidth]{SystemBrowserMethodTemplate}}
   \caption{メソッド作成テンプレートをブラウザに表示
   \figlabel{SystemBrowserMethodTemplate}}
\end{figure}

%---------------------------------------------------------
\subsection{コード空間を渡り歩く}

ブラウザはコードを探したり分析したりするためのいくつかのツールを提供します。
これらのツールは、様々なコンテキストメニューを\actclick することで利用できます。また、特に最も頻繁に使われるツールなどにはキーボードショートカットが用意されています。

\subsubsection{新しいブラウザウィンドウを開く}
\seclabel{browsing}

時折、複数のブラウザウィンドウを開きたくなる場合があります。
コードを書いているときは少なくとも二つ必要でしょう。一つは入力中のメソッドのため、もう一つは物事がどう動いているのか調べるのにシステム周りを見るためです。
テキスト中でクラス名を選択した後に\ind{キーボードショートカット}\short{b}を使えば、そのクラスを表示するブラウザを起動することができます。
\index{browser!browse button}
\index{keyboard shortcut!browse it}

\dothis{次のことを試してみてください: ワークスペースウィンドウ内でクラス名(例えば\ct{Morph})を入力し、それを選択し\short{b}を押してください。この方法はよく役に立ち、どのテキストウィンドウでも使えます。}

\subsubsection{メッセージのセンダとインプリメンタ}
\seclabel{sendersImplementors}

\index{browser!senders}
メソッドペインで\menu{browse \ldots \go senders (n)}を\actclick すると、選択したメソッドを使用しているすべてのメソッドのリストが表示されます。ブラウザを開いて\ct{Morph}を選択した後、メソッドペインの中の\mthind{Morph}{drawOn:}メソッドをクリックすると、\ct{drawOn:}本体がブラウザ下部に表示されます。 \menu{senders (n)} (\figref{SendersOfDrawOn})を選ぶと、\ct{drawOn:}を一番上の項目としたメニューが現れ、以下\ct{drawOn:}が送るすべてのメッセージ(\figref{SendersOfDrawOn2})が順に表示されます。このメニューの項目を選ぶと、選択したメッセージ(\figref{CanvasDraw})を送る仮想イメージ内の全メソッドのリストがブラウザで表示されます。

%\begin{figure}[htb]
%\begin{minipage}[b]{0.74\textwidth}
%\centerline {\includegraphics[width=\textwidth]{SendersOfDrawOn}}
%\caption{The \menu{senders (n)} menu item.\figlabel{SendersOfDrawOn}}
%\end{minipage}
%\hfill
%\begin{minipage}[b]{0.24\textwidth}
%\centerline {\includegraphics[width=\textwidth]{SendersOfDrawOn2}}
%\caption{Choose senders of which message.\figlabel{SendersOfDrawOn2}}
%\end{minipage}
%\end{figure}

\begin{figure}[htb]
\centerline {\includegraphics[width=\textwidth]{SendersOfDrawOn}}
\caption{\menu{senders (n)}メニュー項目。\figlabel{SendersOfDrawOn}}
\end{figure}

\begin{figure}[htb]
\centerline {\includegraphics[width=0.4\textwidth]{SendersOfDrawOn2}}
\caption{メッセージのセンダを選択。\figlabel{SendersOfDrawOn2}}
\end{figure}

\menu{senders (n)}の中の``n''は、メッセージのセンダを探すためのキーボードショートカットが\short{n}であることを示しています。この方法は、\emph{どの}テキストウィンドウでも使えます。

\dothis{コードペインにあるテキスト``drawOn:''を選択して\short{n}を押せば、直ちに\ct{drawOn:}のセンダが表示されます。}

\begin{figure}[htbp]
\begin{center}
   \ifluluelse
{\includegraphics[width=\textwidth]{CanvasDraw}}
{\includegraphics[width=0.7\textwidth]{CanvasDraw}}
\end{center}
\caption{センダブラウザは \ct{Canvas>>>draw}メソッドが、引数に対して\ct{drawOn:}メッセージを送っていることを表しています。\figlabel{CanvasDraw}}
\end{figure}

\ct{AtomMorph>>>drawOn:}にある\ct{drawOn:}のセンダを探せば、それがsuper \subind{super}{send}であることがわかるでしょう。つまり、実行されるメソッドは\ct{AtomMorph}のスーパークラスにあることがわかります。ではいったいどのクラスでしょうか? \menu{browse \go hierarchy implementors}を\actclick すれば、そのメソッドが\ct{EllipseMorph}クラスにあることがわかります。
\index{browser!hierarchy button}

\figref{CanvasDraw}のリストの6番目にあるセンダ\ct{Canvas>>>draw}を見てみましょう。
このメソッドは、引数として渡されたどんなオブジェクトに対しても\ct{drawOn:}を送ることがわかります。つまり、あらゆるクラスのインスタンスが引数となる可能性があります。
データフロー解析がいくつかのメッセージのレシーバクラスを把握する助けにはなりますが、一般的には、ブラウザを使ってもどのメッセージ送信がどのメソッドの実行につながるのかを知る簡単な方法はありません。
このような理由から``センダ'' ブラウザは、メッセージが示唆するメソッドだけ、つまり選択されたセレクタを持つすべてのメッセージセンダを表示します。
それにも関わらず、どのようにメソッドを\emph{使う}のかを理解する必要があるときには、すぐに使用例を導けるのでセンダブラウザが大いに役立ちます。
同じセレクタを持つすべてのメソッドは同じように使われるはずなので、メッセージの使い方はどれも似ているはずです。
\index{browser!senders}

\index{browser!implementors}
インプリメンタブラウザも似たような動作をしますが、メッセージセンダのリストの代わりに、同じセレクタを持つメソッドを実装している全クラスのリストを表示します。
このことを確かめるために、メソッドペインにある\lct{drawOn:}を選び、\menu{browse \go implementors (m)}を選びます(もしくはコードペイン中のテキスト``drawOn:''を選択し、\short{m}を押します)。すると、\ct{drawOn:}メソッドを実装する90余りのクラスが、スクロール可能なメソッドリストのウィンドウとして表示されます。
これほど多くのクラスがこのメソッドを実装していることに驚く必要はありません。\ct{drawOn:}は、画面上に自分自身を描画することができるすべてのオブジェクトによって理解されるメッセージなのです。

\subsubsection{メソッドのバージョン}
\seclabel{versions}

新しい\subind{method}{バージョン}のメソッドを保存しても、古いものは失われません。\pharo はすべての古いバージョンを保存し、異なるバージョンを比較したり、古いバージョンに戻したり(``復帰'')することができます。
\begin{figure}[btp]
   \centering
   \includegraphics[width=\textwidth]{Versions}
   \caption{\ind{バージョンブラウザ}が二つの\ct{TheWorldMenu>>>buildWorldMenu:}メソッドを表示}
   \figlabel{buildWorldMenuVersions}
\end{figure}
\menu{browse \go versions (v)}メニュー項目により、選択したメソッドに加えられた一連の変更を調べることができます。
\figref{buildWorldMenuVersions}では、\ct{buildWorldMenu:}メソッドの二つのバージョンを示しています。

\index{browser!versions button}
上部のペインには、そのメソッドのバージョンごとに1行ずつ表示されており、このメソッドを書いたプログラマのイニシャル、保存した日時、クラスとメソッドの名前、そして定義されているプロトコルが表示されます。現在の(アクティブな)バージョンはリストの一番上にあります。選択されたバージョンは、下部のペインに表示されます。
% If the \menu{diffs} checkbox is selected, as it is in \figref{mouseUpVersions}, the display also shows the differences between the selected version and the one immediately older.
選択されたメソッドと現在のバージョンの違いを表示したり、選択したバージョンに復帰したりするためのボタンが用意されています。
% The \menu{prettyDiffs} checkbox is useful if there have been changes to layout: it pretty-prints both versions before differencing, so that the differences that are displayed exclude formatting changes.

\ind{バージョンブラウザ}の存在は、必要なコードを残すべきか悩む必要がなく、単に削除すれば良いことを意味しています。もしそのコードが\emph{本当に}必要だとわかったら、いつでも古いバージョンに復帰することができますし、古いバージョンから必要なコードの断片を得て別のメソッドに貼り付けることもできます。
バージョンブラウザを使う癖を付けましょう。もはや必要のなくなったコードをコメントアウトするのは悪い習慣です。なぜなら、そのことで現在のコードが読みにくくなるからです。
Smalltalkerは読みやすいコードを非常に高く評価します。

\hint{メソッド全体を削除した後で、元に戻したい場合はどうすればいいでしょう? チェンジセットの中に削除したものを見つけることができます。そこで\actclick することにより、以前のバージョンを確認できます。
チェンジセットブラウザは\secref{env:changeSet}で述べられています。}

\subsubsection{メソッドのオーバーライド}
\seclabel{overriding}

インヘリタンスブラウザは、表示されたメソッドによってオーバーライドされたすべてのメソッドを表示します。
どのように動作するかを見るために、ブラウザで\cmind{ImageMorph}{drawOn:}メソッドを選択してください。
メソッド名の隣にある三角形のアイコンに注目してください。(\figref{OBinheritanceBrowser})
上向きの三角形は、\ct{ImageMorph>>>drawOn:}が継承されたメソッド(\ie \ct{Morph>>>drawOn:})をオーバーライドしていることを示しており、さらに下向きの三角形は、サブクラスによってオーバーライドされていることを示しています。(アイコンをクリックすることで、これらのメソッドに移動することもできます。)
ここで、\menu{browse \go inheritance}を選択してください。
インヘリタンスブラウザが、オーバーライドされたメソッドの階層関係を示します。(\figref{OBinheritanceBrowser}参照)

\begin{figure}[btp]
\begin{center}
   \ifluluelse
{\includegraphics[width=\textwidth]{OBInheritanceOverriding}}
{\includegraphics[width=0.7\textwidth]{OBInheritanceOverriding}}
\end{center}
\caption{\ct{ImageMorph>>>drawOn:} とそれがオーバーライドしたメソッド。選択したメソッドの兄弟関係がリストに表示されている。}
\figlabel{OBinheritanceBrowser}
\end{figure}

\subsubsection{階層ビュー}
\seclabel{hierarchy}

標準では、ブラウザは左端のペインにパッケージのリストを表示します。
しかしクラスの階層ビューに切り替えることは可能です。
関心のある特定のクラスを選択してください。例えば\ct{ImageMorph}を選択し、\button{hier.}ボタンをクリックします。
選択したクラスのすべてのスーパークラスとサブクラスを含むクラス階層を、左端のペインで見ることができます。
二つ目のペインは選択したクラスのメソッドを実装するパッケージのリストが表示されます。\footnote{訳注：バージョン1.4では階層ブラウザが表示されますが、二つ目のペインにパッケージのリストは表示されません}
%The \button{hierarchy} button opens a \ind{hierarchy browser} on the current class; this
%browser can also be opened by using the \menu{browse hierarchy} menu item in the class pane.
%The hierarchy browser is similar to the browser, but instead of displaying the categories and the classes in each category, it shows a single list of classes, indented to represent inheritance.
%The category of the selected class is displayed in the small annotation pane at the top of the browser.
\figref{hierarchyBrowser}では、\clsind{ImageMorph}のスーパークラスが \clsind{Morph}であることを階層ブラウザが示しています。
\index{browser!hierarchy button}

\begin{figure}[btp]
\begin{center}
\ifluluelse
{\includegraphics[width=\textwidth]{hierarchyBrowser}}
{\includegraphics[width=0.7\textwidth]{hierarchyBrowser}}
\end{center}
\caption{\ct{ImageMorph}の階層ビュー}
\figlabel{hierarchyBrowser}
\end{figure}

\subsubsection{変数への参照を見つける}
\seclabel{variables}

\index{browser!variables}
クラスペインにあるクラスを\actclick し、\menu{browse \go chase variables}を選択することで、インスタンス変数やクラス変数が使われている場所を見つけることができます。
\emph{追跡ブラウザ}を使うことで、すべてのインスタンス変数やクラス変数のアクセサ、さらにこれらのアクセサを送るメソッドなどを探索することができます(\figref{chasingBrowser})。

\begin{figure}[btp]
\begin{center}
\ifluluelse
{\includegraphics[width=\textwidth]{chasingBrowser}}
{\includegraphics[width=0.7\textwidth]{chasingBrowser}}
\end{center}
\caption{\ct{Morph}に対する追跡ブラウザ}
\figlabel{chasingBrowser}
\end{figure}

% The menu also includes \menu{inst var defs}, which shows the subset of the instance variable references that assign to the variable.
%Once you click on the button or select the menu item, you will be presented with a dialog that invites you to choose a variable from all of the variables defined in the current class, and all of the variables that it inherits. The list is in inheritance order; it can often be useful to bring up this list just to remind yourself of the name of an instance variable. If you click outside the list, it will go away and no variable browser will be created.

%Also available by \actclick{ing} the class pane is \menu{class vars}, which opens an inspector showing the class variables of the current class \emph{and their values}, and \menu{class refs (N)} which displays a list of all of the methods that directly reference the current class.

\subsubsection{ソース}
\seclabel{sources}

\index{browser!view}
メソッドペインを\actclick することで利用可能となる\menu{various \go view \ldots}メニュー項目は、``how to show''メニューを表示しますが\footnote{訳注：バージョン1.4ではメソッドペインの下にあるViewボタンを押すと``Choose''メニューが表示されます}、これは選択されたメソッドをソースペインでブラウザがどのように表示するかを選ばせるものです。 \menu{source}（ソースコード）、\menu{prettyPrint}（整形されたソースコード）、\menu{byteCode}（バイトコード）および\menu{decompile}（バイトコードから逆コンパイルされたソースコード）といった選択肢があります。
% The label on the button changes if you select one of the other modes. There are other options too; if you let the mouse linger over the names, a help balloon will appear. Try some of them.
\index{method!pretty-print}
\index{method!decompile}
\index{method!byte code}

``how to show''メニューで選択した\menu{prettyPrint}は、ソースを保存する前に整形出力したメソッドと同じもの\footnote{\menu{pretty print (r)}はメソッドペインの最初のメニュー項目もしくはコードペインの真ん中下側にあります。}\footnote{訳注：バージョン1.4では、メソッドペインおよびコードペインでの整形出力機能はありません。}ではないことに注意してください。
このメニューは、ブラウザの表示方法を制御するだけで、システムに格納されたコードには何の影響も及ぼしません。
二つのブラウザを開いて一方のブラウザで\menu{prettyPrint}を選び、もう一方のBrowserで\menu{source}を選ぶことで、このことを確認できます。
同じようにして、二つのブラウザで同じメソッドを表示させた状態で、一方で\menu{byteCode}を選択し、もう一方で\menu{decompile}選択することは、\pharo の仮想マシンのバイトコードの命令セットについて学ぶ良い方法です。

\subsubsection{リファクタリング}

コンテキストメニューから多くの標準的なリファクタリングが行えます。
4つのペインのどれでも\actclick すれば、現在リファクタリング可能な操作を見ることができます。
\figref{refactoring}を参照してください。

以前は、リファクタリングのためにリファクタリングブラウザと呼ばれる特殊なブラウザを使う必要がありましたが、現在はどのブラウザからも利用できます。

\begin{figure}[btp]
\begin{center}
\ifluluelse
{\includegraphics[width=\textwidth]{refactoring}}
{\includegraphics[width=0.7\textwidth]{refactoring}}
\end{center}
\caption{リファクタリング操作}
\figlabel{refactoring}
\end{figure}

%---------------------------------------------------------
\subsection{ブラウザのメニュー}

ブラウザのペインを\actclick することで多くの追加機能を利用することができます。
たとえメニュー項目上のラベルが同じであっても、その\emph{意味}は文脈に依存します。
例えばパッケージペイン、クラスペイン、プロトコルペイン、そしてメソッドペインのすべてが\menu{File out}メニュー項目を持っています。しかしそれらは異なる動作をします。パッケージペインの\menu{File out}メニューは、パッケージ全体をファイル出力します。クラスペインの\menu{File out}メニューはクラス全体をファイル出力します。プロトコルペインの\menu{File out}メニューはプロトコル全体をファイル出力します。そしてメソッドペインの\menu{File out}メニューは表示されたメソッドだけをファイル出力します。
このことは明らかだと思えるかもしれませんが、初心者にとっては混乱の元になります。
\index{file!filing in}
\index{file!filing out}

おそらくパッケージペインの中で最も便利なメニュー項目は\menu{find class\ldots (f)}です。カテゴリは活発に開発しているコードについては役立ちますが、ほとんど誰もシステム全体のカテゴリ化について知りませんし、クラスがどのパッケージにあるか推測するよりも、クラス名の先頭の数文字を入力した後でshort{f}と入力した方がずっと早いのです。\menu{recent classes\ldots}はたとえクラス名を忘れてしまっても、最近ブラウズしたクラスへ素早く戻るのに役立ちます。
\index{class!finding}
\index{class!recent}

ブラウザの左上にある検索ボックスに名前を入力することで、特定のクラスやメソッドを探すこともできます。リターンキーを入力するとシステムに問い合わせがなされ、その結果が表示されます。検索語の前に\ct{#}を付けることで、クラスへの参照や、メッセージのセンダを探せることに気をつけてください。
%To browse to a particular method, you can
%In the class pane, there are two menu items \menu{find method} and \menu{find method wildcard\ldots} that can be useful if you want to browse a particular method.
選択したクラスの特定のメソッドを探すのであれば、(デフォルトで表示される)\prot{-{}-all-{}-}プロトコルをブラウズした方が速いでしょう。メソッドペインにマウスを移動し、探そうとしているメソッド名の最初の文字を入力してください。
メソッドペインがスクロールして、探しているメソッド名が見えるでしょう。
\index{method!finding}
\protindex{all}

\dothis{\cmind{OrderedCollection}{removeAt:}で二つの操作方法を試してください。}

メニューには他の多くのオプションがあります。少々の時間を取って、ブラウザ上のどこにどのような機能があるかを探しておくと、後ほど報われることでしょう。

\dothis{クラスペインメニューの\menu{Browse Protocol}, \menu{Browse Hierarchy}, そして\menu{Show Hierarchy}の結果を比較してください。}

%---------------------------------------------------------
\subsection{プログラムによるブラウズ}

\glbind{SystemNavigation}クラスはシステム周りを操作するために役に立つユーティリティメソッドのいくつかを提供しています。
典型的なブラウザが提供する機能の大半は、\ct{SystemNavigation}によって実装されています。
\index{browsing programmatically}

\dothis{
\ct{drawOn:}:のセンダを見るためには、ワークスペースを開いて以下のコードを評価してください。}
\begin{code}{}
SystemNavigation default browseAllCallsOn: #drawOn:
\end{code}
センダの検索を特定のクラスのメソッドに制限するには以下のようにします。
\begin{code}{}
SystemNavigation default browseAllCallsOn: #drawOn: from: ImageMorph
\end{code}
開発ツールもオブジェクトなので、プログラムから完全にアクセス可能であり、自分自身のツールを開発することや既存のツールを必要に応じて変更することもできます。

\menu{implementors}メニュー項目と等価なプログラムは以下のようなものです。
\begin{code}{}
SystemNavigation default browseAllImplementorsOf: #drawOn:
\end{code}

他に何ができるのかを知るには、ブラウザで\ct{SystemNavigation}クラスを探してください。
その他の操作例については、FAQ(\appref{faq})で見つけることができます。

%=========================================================
\section{Monticello}

\secref{Monticello}において、\pharo のパッケージ作成ツールである\ind{Monticello}の概要について説明しました。
しかし、Monticelloは、その章で述べたこと以上の特徴を備えています。
Monticelloは\emph{パッケージ}を扱うので、Monticelloについて説明する前に、まず\ind{パッケージ}が何なのかということを正確に説明する必要があります。

%---------------------------------------------------------
\subsection{パッケージ: \pharo コードの宣言的なカテゴリ化}\seclabel{packages}

かなり前の\secref{categoriesPackages}において、パッケージとは概ねカテゴリと同等のものであると指摘しました。ここでは、その関係が実際には何であるか見ていきます。
パッケージシステムとは、\st ソースコードを組織化するためのシンプルで軽量な方法のことです。これは、カテゴリとプロトコルに対して簡単な命名規則を利用します。

例を使って説明しましょう。
あるフレームワークを開発していると仮定しましょう。これは \pharo から関係データベースを簡単に利用するためのものです。あなたはこのフレームワークを\ct{PharoLink}と呼ぶことにしました。そして、作成したクラスすべてを含むような一連のカテゴリを作ったとします。例えば、
\ct{'PharoLink-Connections'}カテゴリは\ct{OracleConnection MySQLConnection PostgresConnection}を含み、\ct{'PharoLink-Model'}カテゴリは\ct{DBTable DBRow DBQuery}等を含みます。しかし、作成したコードのすべてがこれらのクラスの中にあるわけではありません。例えば、オブジェクトをSQL的な形式に変換するための一連のメソッドもあるかもしれません。

\begin{code}{}
Object>>>asSQL
String>>>asSQL
Date>>>asSQL
\end{code}

\noindent
これらのメソッドは、
% \damien{don't we say 'belong to'?}
% \on{no -- belong in = they should be there; belong to = they are there}
\ct{PharoLink-Connections}や\ct{PharoLink-Model}カテゴリと同じパッケージに属しています。
しかし、明らかに\ct{Object}クラス全体がそのパッケージに属するわけではありません。
つまり、クラスの残りが別のパッケージにあるとしても、特定の\emph{メソッド}をパッケージに含める方法が必要になります。

\index{package!extension}
\seeindex{extension package}{package, extension}

それを行う方法は、(\ct{Object}, \ct{String} \ct{Date}等)のメソッドを、prot{*PharoLink}(最初のアスタリスクに注意してください)というプロトコルに置くことです。\scat{PharoLink-\ldots}カテゴリと\prot{*PharoLink}プロトコルの組み合わせが、\ct{PharoLink}パッケージを形作ります。
正確には、パッケージに置かれる規則は以下の通りです。

\ct{Foo}と名付けられたパッケージは次のものを含みます。

\begin{enumerate} \seclabel{packageRules}
\item{} \scat{Foo}カテゴリもしくは\scat{Foo-}で始まる名前のカテゴリ内にある、クラスのすべての\emph{クラス定義}
\item{} \label{env:extensions} \prot{*Foo}や\prot{*foo}\footnote{比較の際に大文字か小文字かは無視されます。}という名前のプロトコルか、\prot{*Foo-}や\prot{*foo-}で始まる名前のプロトコルにある、\emph{任意のクラス}内のすべての\emph{メソッド}
\item{} \scat{Foo}カテゴリか、\scat{Foo-}で始まる名前のカテゴリのクラスにあるすべての\emph{メソッド}。ただし\prot{*}で始まる名前のプロトコルにあるメソッドは\emph{除外される}。

\end{enumerate}
\noindent
これらの規則の結果、各クラスの定義と各メソッドが、ちょうど一つのパッケージに属することになります。最後の規則にある\emph{例外}は、それらのメソッドが他のパッケージに属すために必要となります。規則\ref{env:extensions}にある、大文字小文字が無視されるというのは、カテゴリ名がキャメルケース（空白を含まない）のに対して、（必ずというわけではないが）典型的なプロトコル名が小文字である（空白を含む場合がある）からです。
\index{camelCase}

\ct{PackageInfo}クラスがこれらの規則を実装しており、このクラスを試すことで規則の感触を掴むことができます。

\dothis{ワークスペース上で以下の式を評価してください。}

\begin{code}{}
mc := PackageInfo named: 'Monticello'
\end{code}

さて、このパッケージについて探索できるようになりました。
例えば、ワークスペース上で\ct{mc classes}を表示することで、Monticelloパッケージを構成するクラスの長いリストが得られます。
\ct{mc coreMethods}
は、これらのクラスにあるすべてのメソッドに対する\ct{MethodReference}のリストが返されます。\ct{mc extensionMethods}は、おそらく最も面白い問い合わせでしょう。この問い合わせは、\ct{Monticello}パッケージに含まれるすべてのメソッドのうち、\lct{Monticello}クラスを除いたものを返します。

パッケージは比較的新しく\pharo に加えられたものです。しかし、パッケージの命名規則は、既に使われていたものをベースとしていたため、パッケージの採用を意識していない古いコードを分析する際にも\ct{PackageInfo}を使うことができます。

\dothis{\ct{(PackageInfo named: 'Collections') externalSubclasses}を\lct{表示}してください。この式は、\ct{Collection}パッケージに\emph{含まれていない}\ct{Collections}のすべてのサブクラスの一覧を返します。}

%---------------------------------------------------------
\subsection{Monticelloの基礎}

\ind{Monticello}は、合衆国3番目の大統領であり「バージニア信教自由法」の起草者であるトーマス・ジェファーソンの山頂の家にちなんで名付けられました。この名前はイタリア語で``小さな山''を意味し、イタリア語の発音に従い``c''をchairの``ch''と発音して「モンティチェロ」といいます。


\begin{figure}[btp]
\begin{center}
\ifluluelse
{\includegraphics[width=\textwidth]{freshMonticello}}
{\includegraphics[width=0.7\textwidth]{freshMonticello}}
\end{center}
\caption{Monticelloブラウザ}
\figlabel{freshMonticello}
\end{figure}

Monticelloブラウザを開くと、\figref{freshMonticello}のように、二つのペインと1列に並んだボタンが表示されます。
左側のペインには、実行中の仮想イメージにロードされたすべてのパッケージが表示され、名前の後の括弧の中にはパッケージを特定するバージョンが表示されます。

右側のペインには、Monticelloが知っているすべてのソースコードリポジトリが表示されており、通常はそれらのリポジトリからコードがロードされます。左側のペインにあるパッケージを選ぶと、右側のペインには、選択したパッケージのバージョンを含むリポジトリのみを表示するようにフィルタリングされます。

リポジトリの一つは\emph{package-cache}と呼ばれるディレクトリで、実行中のイメージファイルのあるディレクトリのサブディレクトリです。
遠隔地にあるリポジトリからコードを読み込んだり、書き込んだりする場合、コピーがpackage-cacheにも保存されます。ネットワークが利用できない場合にパッケージへアクセスする必要のあるとき、package-cacheが役立ちます。また、例えば電子メールの添付ファイルとしてMonticelloファイル(.mcz)が直接与えられた場合、そのファイルをpackage-cacheディレクトリに置くのが一番手軽なアクセス方法となります。
\index{package!cache}

リストに新しいリポジトリを追加するには、\button{+Repository}ボタンをクリックし、ポップアップメニューからリポジトリの種類を選んでください。ではHTTPリポジトリを追加しましょう。

\dothis{Monticelloを開き、\button{+Repository}ボタンをクリックし、\menu{HTTP}を選びます。
以下のようにダイアログ内容を編集してください。}
%\ab{How does one continue the $\backslash$dothis to include the code?}
%\on{Don't. Just close the \dothis{} and follow with the code.}
\needlines{4}
\begin{code}{}
MCHttpRepository
location: 'http://squeaksource.com/PharoByExample'
user: ''
password: ''
\end{code}

\begin{figure}[btp]
\begin{center}
\ifluluelse
{\includegraphics[width=0.7\textwidth]{SqueakSource-PBE}}
{\includegraphics[width=0.7\textwidth]{SqueakSource-PBE}}
\end{center}
\caption{リポジトリブラウザ}
\figlabel{SqueakSource:PBE}
\end{figure}
\noindent
その後、このリポジトリをリポジトリブラウザで開くために、\button{Open}ボタンをクリックします。\figref{SqueakSource:PBE}のようなものが見えるでしょう。左側のペインには、リポジトリ内のすべてのパッケージのリストがあります。その中の一つを選択すれば、右側のペインにこのリポジトリ内にある選択されたパッケージのすべてのバージョンが表示されます。

その中の一つのバージョンを選択すると、\button{Browse}ボタンでの(イメージファイルに読み込むことなしに)ブラウズや\button{Load}ボタンでの読み込み、そして、\button{Changes}ボタンでは、選択したバージョンを読み込んだ場合の変更点を見ることができます。\button{Copy}ボタンでは、任意のバージョンのパッケージのコピーを作成して、他のリポジトリに書き込むこともできます。

見ればわかる通り、バージョン名には、パッケージ名、バージョン作成者のイニシャル、およびバージョン番号が含まれています。バージョン名はリポジトリ内のファイル名でもあります。これらの名前を変更してはいけません。なぜならMonticelloの適切な操作は、これらの名前に依存しているからです! Monticelloのバージョンファイルは単なるzipアーカイブであり、興味があればzipツールを使ってファイルを解凍できますが、その内容を見る最良の方法は、Monticello自体を使うことです。

Monticelloでパッケージを作成するには、二つのことを行う必要があります。一つはコードを書くこと、もう一つはそれをMonticelloに伝えることです。

\dothis{\scat{PBE-Monticello}というパッケージを作成し、\figref{MCnewcategory}のように二つのクラスをその中に置いてください。もちろん、\ct{Object}などの既存のクラスのメソッドを作り、\pageref{sec:packageRules}ページにある規則を使ってこのクラスと同じパッケージに置いてください\,---\,\figref{MCnewmethod}を参照のこと。}

\begin{figure}[btp]
\begin{center}
\ifluluelse
{\includegraphics[width=\textwidth]{MCnewcategory}}
{\includegraphics[width=0.7\textwidth]{MCnewcategory}}
\end{center}
\caption{``PBE''パッケージの二つのクラス。}
\figlabel{MCnewcategory}
\end{figure}

\begin{figure}[btp]
\begin{center}
\ifluluelse
{\includegraphics[width=\textwidth]{MCnewmethod}}
{\includegraphics[width=0.7\textwidth]{MCnewmethod}}
\end{center}
\caption{``PBE''パッケージに置かれる拡張メソッド。}
\figlabel{MCnewmethod}
\end{figure}

作成したパッケージをMonticelloに伝えるために、\button{+Package}ボタンをクリックし、パッケージ名、この場合は``PBE''を入力してください。Monticelloは\ct{PBE}をパッケージリストに加えます。パッケージはアスタリスクでマークされ、仮想イメージ内のバージョンがどのリポジトリにも書き込まれていないことを示します。ここで、Monticelloに二つのパッケージを持つことに注意してください。一つは\ct{PBE}、もう一つは\ct{PBE-Monticello}です。\ct{PBE}は\ct{PBE-Monticello}や\ct{PBE-}で始まる他のすべてのパッケージを含むため、これでよいのです。

最初はこのパッケージに関連している唯一のリポジトリは、\figref{MC+PBE}に示されているようにパッケージキャッシュだけです。それで問題なく、コードを保存することができますし、パッケージキャッシュに格納されます。
\button{Save}ボタンをクリックすると、\figref{PBE-on}のように保存するパッケージのバージョンに対するログメッセージを入力するよう求められます。このメッセージをアクセプトするとMonticelloはパッケージを保存します。
保存したことを示すため、Monticelloのパッケージペインに付けられていたアスタリスクがなくなり、バージョン番号が付与されます。

もしパッケージに変更を加えた\,---\, 例えばクラスの一つにメソッドを追加した \,---\, 場合、アスタリスクが再び現れて、変更が保存されていないことを示します。パッケージキャッシュをリポジトリブラウザで開いて保存したバージョンを選べば、\button{Changes}ボタンや他のボタンを使うことができます。
もちろんリポジトリに新しいバージョンを保存することもできます。\button{Refresh}ボタンを押してリポジトリビューを一度更新すれば、\figref{package-cache-browser}のように表示されるはずです。
\index{package!cache}

\begin{figure}[tbp]
\begin{center}
\includegraphics[width=\textwidth]{MC+PBE}
\end{center}
\caption{Monticelloでまだ保存されていないPBEパッケージ。}
\figlabel{MC+PBE}
\end{figure}

\begin{figure}[tbp]
\begin{center}
\includegraphics[width=0.8\textwidth]{PBE-on}
\end{center}
\caption{パッケージの新バージョンに対するログメッセージを入力する。}
\figlabel{PBE-on}
\end{figure}

\begin{figure}[tbp]
\begin{center}
\includegraphics[width=\textwidth]{package-cache-browser}
\end{center}
\caption{作成したパッケージの二つのバージョンがパッケージキャッシュにあります。}
\figlabel{package-cache-browser}
\end{figure}

新しいパッケージをパッケージキャッシュ以外のリポジトリに保存するためには、必要に応じてリポジトリを追加するなどして、まずMonticelloにそのリポジトリについて知らせる必要があります。
その後、パッケージキャッシュ上のリポジトリブラウザで\button{Copy}ボタンを使って、コピー先のリポジトリを選ぶことができます。
\figref{associateRepository}のようにリポジトリ上で\actclick し、\menu{add to package \ldots}を選ぶことで、お望みのリポジトリをパッケージと関連づけることもできます。
いったんパッケージがリポジトリに関連づけば、Monticelloブラウザでリポジトリとパッケージを選んで\button{Save}ボタンをクリックすることで、新しいバージョンを保存することができます。
もちろんリポジトリへ書き込むためのパーミッションは必要です。
\emphind{\sqsrc}上の\ct{PharoByExample}リポジトリは世界から読むことができますが、書き込むことはできません。そこに保存しようとしてもエラーメッセージが表示されるでしょう。
しかし、\sqsrc にあなた専用のリポジトリを作成することは可能です。\url{http://www.squeaksource.com}にあるWebインターフェースを使って、あなたのパッケージを保存するリポジトリを利用できます。
これは、友人とコードを共有したり複数のコンピュータを使ったりする場合などの仕組みとして特に有用です。

\begin{figure}[tbp]
\begin{center}
\includegraphics[width=\textwidth]{MCaddToPackage}
\end{center}
\caption{パッケージに関連づけられたポジトリのセットにリポジトリに追加する。}
\figlabel{associateRepository}
\end{figure}

書き込みパーミッションを持たないリポジトリに対して保存しようとした場合、ともかくそのバージョンはパッケージキャッシュに書き込まれます。
つまり、リポジトリの情報を編集するか(Monticelloブラウザで\actclick )別のリポジトリを選んで、パッケージキャッシュブラウザから\button{Copy}ボタンを押せば、そのバージョンを復活させることができます。

%=========================================================
\section{インスペクタと[Explore]}
\seclabel{inspector} % (fold)

\st が他の多くの言語と異なる特徴の一つは、静的なコードの世界ではなく、生きたオブジェクトの世界へ開かれた窓を提供しているということです。
そこではどのようなオブジェクトでもプログラマによって調べることが可能です。さらには変更することさえできます。\,---\, ただし、システムを構成している基本的なオブジェクトを変更するようなときには注意が必要です。
もちろん言うまでもなく、最初にイメージを保存しておいてください！

%---------------------------------------------------------
\subsection{インスペクタ}

\dothis{\ind{インスペクタ}を使ってどんなことができるか、実際に見てみるためにワークスペースで \ct{TimeStamp now} と入力し、\actclick で \menu{inpect it} を選んでください。}
(メニューを使う前にテキストを選択しておく必要はありません。テキストが選択されていない場合には、メニュー操作は現在の行すべてを対象にするからです。
\menu{\textbf{i}nspect it} を選ぶ代わりに \short{i} とタイプしても同じです)
\clsindex{TimeStamp}
\index{keyboard shortcut!inspect it}

\begin{figure}[btp]
\begin{center}
\includegraphics[width=\textwidth]{inspectTimeNow1}
\end{center}
\caption{ \ct{TimeStamp now} をインスペクトする}
\figlabel{inspectTimeNow1}
\end{figure}

\figref{inspectTimeNow1} のようなウィンドウが現れます。
これがインスペクタで、特定のオブジェクトの内部に向かって開かれた窓と考えることができます。特定のオブジェクトとはこの場合、 \ct{TimeStamp now} という式を評価することによって生成された \mbox{\ct{TimeStamp}} のインスタンスオブジェクトのことです。
% the \mbox is here because without it, the listings macros puts a space between TimeStamp
% and the following word, and that space happens to come out at the start of a line.

ウィンドウのタイトルバーには、インスペクトしているオブジェクトが印字形式で表示されています。
左側のペインの先頭の \menu{self} を選択すると、右側のペインにそのオブジェクトが文字列で表示されます。
% If you select \menu{all inst vars} in the left pane, the right pane will show a list of the instance variables in the object, and the printstring for each one.
% The remaining items in the left pane represent the instance variables; this makes it easy to examine them one at a time, and also to change them.
左側のペインはそのオブジェクトのツリー構造ビューとなっており、\self をツリーの根としています。
インスタンス変数は、名前の横にある三角形を展開することで探求できます。\footnote{訳注：Pharo 1.2以降ツリーではなく一覧表示に変更されています}

インスペクタの下部にある横長のペインは小さなワークスペースウィンドウです。このウィンドウでは、擬似変数の \ct{self} が左側のペインで選択したオブジェクトに束縛されている\footnote{訳注：Pharo 1.2以降でselfは常にインスペクトしているオブジェクトを束縛しています}ので便利です。
そこで、
\begin{code}{}
self - TimeStamp today
\end{code}
上記の式をワークスペースペインで \menu{inspect it} すると、結果は \clsind{Duration} オブジェクトになります。このオブジェクトは、今日の午前０時と \ct{TimeStamp now} を評価して得られた \ct{TimeStamp} オブジェクト（インスペクトしているもの）との、時間間隔を表しています。
さらに \ct{TimeStamp now - self} を評価すれば、あなたがこのセクションを読むのに費やした時間を教えてくれるでしょう！

\ct{self} だけでなく、オブジェクトのすべてのインスタンス変数も、ワークスペースペインの有効範囲にあります。つまり、変数に対して式で参照したり代入したりすることもできます。例えば、左のペインのツリーの根にあるオブジェクトを選んでから、ワークスペースペインで \ct{jdn := jdn - 1} を評価すると、インスタンス変数 \ct{jdn} の値が実際に変化することがわかりますし、\ct{TimeStamp now - self} の値も1日分増えるでしょう。

% ON: Does not work anymore
%You can change instance variables directly by selecting them, replacing the old value in the right-hand pane by a \pharo expression, and accepting.
%\pharo will evaluate the expression and assign the result to the instance variable.

DictionaryやOrderedCollectionやCompiledMethod、さらにいくつかのクラスに対しては、インスペクタに特別な拡張がなされていて、これらのオブジェクトの内容をより簡単に検査することができます。

%---------------------------------------------------------
\subsection{オブジェクトエクスプローラ}

\emph{オブジェクトエクスプローラ}は概念的にはインスペクタとよく似ていますが、情報の表し方が異なっています。
この相違点を調べるために、先ほどまでインスペクトしていたものと同じオブジェクトを\emph{エクスプローラ}で探求してみましょう。

\begin{figure}[tbp]
\begin{minipage}{0.48\textwidth}
\begin{center}
\ifluluelse
{\includegraphics[width=\textwidth]{exploreTimeStampNow}}
{\includegraphics[width=0.7\textwidth]{exploreTimeStampNow}}
\end{center}
\caption{ \ct{TimeStamp now} を探求する}
\figlabel{exploreTimeStampNow}
\end{minipage}
\hfill
\begin{minipage}{0.48\textwidth}
\begin{center}
\ifluluelse
{\includegraphics[width=\textwidth]{exploreTimeStampNow2}}
{\includegraphics[width=0.7\textwidth]{exploreTimeStampNow2}}
\end{center}
\caption{インスタンス変数を探求する}
\figlabel{exploreTimeStampNow2}
\end{minipage}
\end{figure}

\dothis{インスペクタの左側のペインで \menu{self} を選び、\actclick で \menu{explore (I)} を選んでください}
\ind{エクスプローラ}ウィンドウは \figref{exploreTimeStampNow} のように表示されます。
ツリー構造の \lct{根} の隣にある小さな三角形をクリックすると、ビューが \figref{exploreTimeStampNow2} のように変化します。このビューは、エクスプロアの対象とするオブジェクトのインスタンス変数を表示します。
\ct{offset} の隣の三角形をクリックすると、 \emph{その}インスタンス変数が見えます。
エクスプローラは、複雑な階層構造を探求しなければならない場合に便利なため、この名前が付けられています。
\index{keyboard shortcut!explore it}

オブジェクトエクスプローラのワークスペースペインの働きは、インスペクタのものと若干異なります。
\ct{self} はツリー構造のルートとなっているオブジェクトではなく、現在選択されているオブジェクトに束縛されるようになっています。また、選択されたオブジェクトのインスタンス変数も同様のスコープに従います。

エクスプローラの真価を見るために、深い入れ子構造を持ったオブジェクトを調べてみましょう。

\dothis{ワークスペースで \ct{Object explore} を評価してください}
これは \pharo の \ct{Object} クラスを表すオブジェクトです。
メソッド辞書を表すオブジェクトに加えて、そのクラスのコンパイル済みメソッドも直接ナビゲートできることに注意してください（ \figref{ExploreObject} 参照）。

\begin{figure}[tbp]
\begin{center}
\includegraphics[width=0.5\textwidth]{ExploreObject}
\end{center}
\caption{\ct{Object} クラスを探求する}
\figlabel{ExploreObject}
\end{figure}

%\dothis{Open a browser, and \metaclick five times on the method pane to bring-up the Morphic halo on the \ct{OBPluggableListMorph} that is used to represent the list of messages.
%Click on the \emph{debug} handle \debugHandle{} and select \menu{explore morph}
%from the menu that appears. This will open an Explorer on the \clsind{OBPluggableListMorph} object that represents the method list on the screen.
%Open the root object (by clicking in its triangle), open its \ct{submorphs}, and continue exploring the structure of the objects that underlie this Morph, as shown in \figref{explorePluggableListMorph}.}
%
%\begin{figure}[tbp]
% \begin{center}
% \includegraphics[width=0.7\textwidth]{explorePluggableListMorph}
% \end{center}
% \caption{Exploring a \ct{PluggableListMorph}}
% \figlabel{explorePluggableListMorph}
%\end{figure}

%=========================================================
\section{デバッガ}
\seclabel{debugger} % (fold)

\ind{デバッガ} は間違いなく \pharo のツールの中で一番強力なツールです。ただデバッグのためというだけでなく、新しいコードを書くのにも利用されます。
デバッガのデモンストレーションをするために、バグを作るところから始めましょう！

\dothis{ブラウザを使って、以下のメソッドを \ct{String} クラスに追加してください}

\needlines{7}
\begin{method}[buggy]{バグがあるメソッド}
suffix
"自分自身をファイル名と仮定して、最後のドットから後ろの部分をサフィックスとして返す"
| dot dotPosition |
dot := FileDirectory dot.
dotPosition := (self size to: 1 by: -1) detect: [ :i | (self at: i) = dot ].
^ self copyFrom: dotPosition to: self size
\end{method}

もちろん、こんな簡単なメソッドは動くのが当たり前だろうと確信するので、SUnit のテストも書かずにワークスペースで \ct{'readme.txt' suffix} と入力し、
\menu{print it(p)} を実行します。
すると驚くことに、期待した答え \ct{'txt'} の代わりに、 \figref{PreDebugWindow} のような \clsind{PreDebugWindow} がポップアップします。

\begin{figure}[btp]
\begin{center}
\includegraphics[width=0.8\textwidth]{PreDebugWindow}
\end{center}
\caption{ \ct{PreDebugWindow} によるバグの通知}
\figlabel{PreDebugWindow}
\end{figure}

\ct{PreDebugWindow} はどんなエラーが起きたのかタイトルバーでわかるようになっています。さらに、エラーに至るまでのメッセージの \emphind{スタックトレース} が表示されます。
トレースの一番下を起点とし、 \ct{UndefinedObject>>DoIt} という行が、ワークスペースで \ct{'readme.txt' suffix} を選び、\pharo に \menu{print it} させたときのコンパイルおよび実行されたコードを表しています。
もちろん、このコードは \clsind{ByteString} クラスのオブジェクト(\ct{'readme.txt'})にメッセージ \ct{suffix} を送ります。
これは \ct{String} クラスから継承している \ct{suffix} メソッドの実行を引き起こし、このことがスタックトレースの次の行で \ct{ByteString(String)>>suffix} として表されています。
スタックをさらにたどると、\ct{suffix} メソッドは \ct{detect:} メッセージを送信し、\ldots そして \ct{detect:ifNone:} メソッドが \ct{errorNotFound} を送信していることがわかります。
\clsindex{UndefinedObject}

\begin{figure}[btp]
\begin{center}
\ifluluelse
{\includegraphics[width=\textwidth]{debuggerDetectIfNone}}
{\includegraphics[width=0.7\textwidth]{debuggerDetectIfNone}}
\end{center}
\caption{デバッガ}
\figlabel{debuggerDetectIfNone}
\end{figure}

\emph{なぜ}ドットが見つからなかったのかを調べるために、デバッガ本体が必要なので、\button{Debug} ボタンをクリックします。

%\dothis{You can also open the debugger by clicking on any of the lines on the stack trace. If you do this, the debugger will open already focussed on the corresponding method.}

\figref{debuggerDetectIfNone} にデバッガを示します。最初は威嚇的に見えますが、使うのはとても簡単です。
タイトルバーと一番上のペインは \lct{PreDebugWindow} にあるものととてもよく似ています。
しかし、デバッガではスタックトレースはメソッドブラウザと合体させており、スタックトレース上の行を選択すると対応するメソッドが下のペインに表示されます。
エラーを引き起こした実行はまだイメージ内にありますが、中断状態にあることを意識することは重要です。
スタックトレースの各行は、実行を継続するのに必要なすべての情報を持った実行スタック上のフレームを表しています。これには、計算に伴うすべてのオブジェクトと各インスタンス変数、実行中のメソッドのすべての一時変数も含まれています。

\figref{debuggerDetectIfNone} では、一番上のペインで \ct{detect:ifNone:} メソッドが選択されています。
メソッドの本体は中央のペインに表示されています。\ct{value} メッセージが青くハイライトされているのは、このメソッドではメッセージ \ct{value} を送信し、その結果を待っている状態であることを示しています。

デバッガの一番下の4つのペインは、実際には(ワークスペースペインを持たない)二つの小さなインスペクタです。
左側のインスペクタは現在のオブジェクト、つまり、中央のペインで \self に相当するオブジェクトを表しています。
別のスタックフレームを選ぶと、\self の示すオブジェクトが変わり、
\self{}-インスペクタの内容も変わります。
左下のペインの \self をクリックすると、\self がIntervalオブジェクト \ct{(10 to: 1 by -1)} であることがわかります。これは期待通りのオブジェクトです。
デバッガの小さなインスペクタにワークスペースペインは必要ありません。というのも、すべての変数がメソッドペインの有効範囲内にあるからです。このペインに対する式の入力や選択、それらの式の評価など自由に行うことができます。
そうした変更は、いつでも \menu{cancel(l)} メニューや \short{\textit{l}} を使って取り消せます。
% apb: that lower-case-L is in italics so that it doesn't look like a 1 or a |
\index{keyboard shortcut!cancel}

右側のインスペクタには、現在のコンテキストにおける一時変数が表示されます。
\figref{debuggerDetectIfNone} では、
\ct{value} が、引数 \ct{exceptionBlock} に送られています。

%\dothis{To see the current value of this parameter, click on \ct{exceptionBlock} in the context inspector.
%This will tell you that \ct{exceptionBlock} is \ct{[self errorNotFound: ...]}.
%\on{no longer true!}

スタックトレースで一つ下のメソッドを見ると、\ct{exceptionBlock} は \ct{[self errorNotFound: ...]} です。エラーメッセージが表示されるのは驚くことではありません。

ちなみに、ミニインスペクタに表示された変数に対して完全なインスペクタやエクスプローラを開きたい場合は、単に変数名をダブルクリックするか、変数名を選んで \actclick し、\menu{inspect(i)} もしくは \menu{explore(I)} を選びます。
こうしておくと、他のコードの実行中に変数の変化を見たい場合に便利です。
\index{keyboard shortcut!inspect it}
\index{keyboard shortcut!explore it}

メソッドウィンドウに戻って見てみると、メソッドの最後から2番目の行で、文字列 \ct{'readme.txt'} から \lct{ドット} を見つけようとしており、その実行が目的の行に達していないことがわかります。
\pharo は逆向きに実行させることはできませんが、メソッドを再実行させることは可能で、オブジェクト自体を変化させず、新しいオブジェクトを生成するようなコードの場合にうまく働きます。

\dothis{\button{Restart} をクリックしてください。すると実行位置が現在のメソッドの最初の文に戻ります。
次に送信されるメッセージ {\ct{do:}} が青くハイライトして表示されています( \figref{RestartDetectIfNone} 参照)。}

\begin{figure}[btp]
\begin{center}
\ifluluelse
{\includegraphics[width=\textwidth]{RestartDetectIfNone}}
{\includegraphics[width=0.7\textwidth]{RestartDetectIfNone}}
\end{center}
\caption{\ct{detect: ifNone:} メソッドを再実行した後のデバッガ}
\figlabel{RestartDetectIfNone}
\end{figure}

\button{Into} と \button{Over} ボタンは二つの異なる方法でステップ実行します。\button{Over} ボタンを押した場合、\pharo は現在のメッセージ送信(この場合では \ct{do:})を、エラーが発生しない限り1ステップだけ実行します。
つまり \button{Over} ボタンによって、現在のメソッドの次のメッセージ送信へと移ります。この場合は \ct{value} となります。\,---\, これは、まさしく最初にいた場所なので、大した助けにはなりません。
必要なことは、なぜ \ct{do:} メソッドが求めている文字を見つけられないのかを突き止めることです。

\dothis{\button{Over} ボタンをクリックした後で、\button{Restart} ボタンをクリックして \figref{RestartDetectIfNone} の状態に戻ってください。}

\dothis{\button{Into} ボタンをクリックしてください。\pharo はハイライトされていたメッセージ送信に対応するメソッドの中に入ります。この場合は、\ct{Collection>>do:} です。}

しかし、どちらにしてもこれはあまり助けにならないことがわかります。というのも \ct{Collection>>do:} が壊れていないことはかなり確信が持てます。\pharo に対して \emph{何かを} させているところにバグがあるはずです。
この場合、\button{Through} ボタンを用いるのが適しています。\ct{do:} メソッド自身の詳細を無視して、引数ブロックの実行に焦点を当てたいからです。

\dothis{再度 \ct{detect:ifNone:} メソッドを選び、\button{Restart} ボタンで \figref{RestartDetectIfNone} の状態に戻します。
今度は \button{Through} ボタンを数回クリックします。このとき、コンテキストウィンドウの \ct{each} 変数を選択しておきます。
\ct{do:} メソッドの実行に従って、\ct{each} の内容が \ct{10} からカウントダウンしていくことがわかります。}

\ct{each} の値が \ct{7} のとき、\ct{ifTrue:} ブロックが実行されることを期待しているのですが、そうなっていません。
何が悪いのかを見るため、\figref{steppingIntoValue} で示すように \ct{value:} を \button{Into} ボタンでステップ実行します。

\begin{figure}[btp]
\begin{center}
\ifluluelse
{\includegraphics[width=\textwidth]{steppingIntoValue}}
{\includegraphics[width=0.7\textwidth]{steppingIntoValue}}
\end{center}
\caption{\ct{do:} メソッドを数回 \lct{Through} ボタンでステップ実行した後のデバッガ}
\figlabel{steppingIntoValue}
\end{figure}

\button{Into} ボタンをクリックした後、\figref{dotIsAString} で示した位置にいることがわかります。
一見すると \ct{suffix} メソッドに \emph{戻って} しまったように見えますが、\ct{suffix} メソッドが \ct{detect:} メソッドに引数として渡しているブロックを実行中なのです。
%\on{does not work any more! the debugger does not know about block variables!}
%If you select \ct{i} in the context inspector, you can see its current value, which should be \ct{7} if you have been following along.
%You can then select the corresponding element of \self from the \self{}-inspector.
%In \figref{dotIsAString} you can see that element \ct{7} of the string is character 46, which is indeed a dot.
コンテキストインスペクタで \ct{dot} を選ぶと、その値が \ct{'.'} であることがわかります。
ここに至って、なぜイコールとならなかったかわかりました。\ct{'readme.txt'} の7番目の文字は \ct{Character} なのに、\ct{dot} が \ct{String} となっています。

\begin{figure}[btp]
\begin{center}
\ifluluelse
{\includegraphics[width=\textwidth]{dotIsAString}}
{\includegraphics[width=0.7\textwidth]{dotIsAString}}
\end{center}
\caption{\ct{'readme.txt' at: 7} が \ct{dot} と等しくならない原因を示しているデバッガ}
\figlabel{dotIsAString}
\end{figure}

バグが判明したので修正方法も明白です。\ct{dot}を探す前に、文字へ変換する必要があります。

\begin{figure}[btp]
\begin{center}
\ifluluelse
{\includegraphics[width=\textwidth]{revertDialog}}
{\includegraphics[width=0.7\textwidth]{revertDialog}}
\end{center}
\caption{デバッガの中で \ct{suffix} メソッドを修正する。内側のブロックから抜けだすかどうかの確認}
\figlabel{revertDialog}
\end{figure}

\dothis{\ct{dot := FileDirectory dot first} のように、デバッガの中でコードを正しく修正し、変更を \menu{accept} してください。}

\lct{detect:} の内側にあるブロック内のコードを実行しているため、この修正によっていくつかのスタックフレームが失われることになります。それでよいかどうかを \pharo が確認します( \figref{revertDialog} 参照)、\menu{yes} をクリックして、新しいメソッドを保存(およびコンパイル)します。

%\dothis{Click \button{Restart} and then \button{Proceed}; the debugger window will vanish, and the evaluation of the expression \ct{'readme.txt' suffix} will complete, and print the answer \ct{'.txt'}}

\ct{'readme.txt' suffix} 式の評価は完了し、\ct{'.txt'} という答えを出力します。

この答えは正しいでしょうか？残念ながら、明確に答えることができません。サフィックスは \ct{.txt} であるべきでしょうか？それとも \ct{txt} ？
\ct{suffix} メソッドのコメントは全然明確ではありません。
こうした問題を避ける方法は、答えを定義する \ind{SUnit} テストを書くことです。

\begin{method}[testSuffix]{\ct{suffix} メソッドのための簡単なテスト}
testSuffixFound
self assert: 'readme.txt' suffix = 'txt'
\end{method}

テストの記述に必要な労力は、同じテストをワークスペースで実行するよりも若干多くなりますが、\sunit を使うことで、テストを実行可能な文書として保持し、他人が簡単にテストできるようになります。
さらに、\ct{StringTest} クラスに \mthref{testSuffix} を追加して \sunit でテストを実行すれば、エラーのデバッグに素早く戻ることができます。
\sunit はアサーション違反があるとデバッガを開きますが、\figref{fixOffByOne} のように、スタックフレームを一つ遡り、\button{Restart} ボタンでテストを再実行し、\button{Into} ボタンで \ct{suffix} メソッドに入ることでエラーを修正できます。
その後、\sunit Test Runner で \button{Run Failures} ボタンをクリックして、テストが通過することを確認するだけです。

\begin{figure}[btp]
\begin{center}
\includegraphics[width=\textwidth]{fixOffByOne}
\end{center}
\caption{デバッガの中で \ct{suffix} メソッドを編集する: \sunit のアサーション違反の後にOff-by-one エラーを修正する}
\figlabel{fixOffByOne}
\end{figure}

以下はより良いテストコードです。

\begin{method}[testSuffix2]{\ct{suffix} メソッドのためのより良いテスト}
testSuffixFound
self assert: 'readme.txt' suffix = 'txt'.
self assert: 'read.me.txt' suffix = 'txt'
\end{method}
\noindent
なぜこのテストがより良いものなのでしょう？その理由は、対象となる文字列に一つ以上のドットがある場合に、このメソッドがどのように振る舞うかを読む人に教えてくれているからです。

エラーやアサーション違反の捕捉以外にも、デバッガに入るいくつかの方法があります。
コードの実行によって無限ループに陥ってしまった場合、 \short{.} (あなたが英語を学んだ場所によりますが、終止符またはピリオドと呼ばれるもの)を入力することで、割り込みをかけてその計算状況におけるデバッガを開くことができます。\footnote{同様に、どんなときでも \short{{\sc shift--}.} の入力によって、緊急デバッガが起動することを覚えておくと便利です。}
また、疑わしいコードの箇所に \ct{self halt} と入れておくだけでもいいです。
例えば、\ct{suffix} メソッドであるならば、次のような感じです。
\index{process!interrupting}

\needspace{11ex}
\begin{method}[suffix]{\ct{suffix} メソッドに \ct{halt} を入れる}
suffix
"自分自身をファイル名と仮定して、最後のドットから後の部分をサフィックスとして返す。"
| dot dotPosition |
dot := FileDirectory dot first.
dotPosition := (self size to: 1 by: -1) detect: [ :i | (self at: i) = dot ].
self halt.
^ self copyFrom: dotPosition to: self size
\end{method}

このメソッドを走らせると、 \ct{self halt} の実行により \ind{pre-debugger} が開きますので、そこから、実行を続行させたり、デバッガに入って変数を見たり、ステップ実行したり、コードを編集したりすることができます。

デバッガについては以上ですべてですが、 \ct{suffix} メソッドについてはまだです。
最初のバグで気づいたでしょうが、対象となる文字列にドットがない場合、\ct{suffix} メソッドはエラーを発生します。
これは望ましい振る舞いではないので、こうしたケースで起きることを明示するために二つ目のテストを追加しましょう。

\needlines{3}
\begin{method}[testNoSuffix]{\ct{suffix} メソッドのための二つ目のテスト: 対象がサフィックスを持たない}
testSuffixNotFound
self assert: 'readme' suffix = ''
\end{method}

\needlines{2}
\dothis{ \mthref{testNoSuffix} を \clsind{StringTest} クラスのテストスイートに追加し、テストがエラーを起こすところを見ます。
\sunit でエラーが起きたテストを選んでデバッガに入り、テストを通過させるためにコードを編集します。
最も簡単で明解な方法は、\ct{detect:} メッセージの代わりに \ct{detect:ifNone:} を用い、2番目の引数を単に文字列の大きさを返すブロックとすることです。}

SUnitについては \charef{SUnit} でより詳しく学びます。

% section debugger (end)

%=========================================================
\section{プロセスブラウザ}

\st はマルチスレッドなシステムです。イメージ中では、たくさんの軽量プロセス(スレッドとして知られる)が並行して走っています。
将来的には \pharo の仮想機械は可能ならばマルチプロセッサを利用するようになるかもしれませんが、現時点では、平行性は時分割処理で実装されています。

\begin{figure}[btp]
\begin{center}
\ifluluelse
{\includegraphics[width=\textwidth]{processBrowser}}
{\includegraphics[width=0.7\textwidth]{processBrowser}}
\end{center}
\caption{プロセスブラウザ}
\figlabel{processBrowser}
\end{figure}

プロセス \subind{プロセス}{ブラウザ} は、デバッガの親類で、\pharo の中で稼働している様々なプロセスを見せてくれます。
\figref{processBrowser} にスクリーンショットを示します。
左上のペインは \pharo の中のすべてのプロセスのリストで、優先度80の割り込みタイマー監視のプロセスから、優先度10のアイドルプロセスに至るまでが優先度順に並んでいます。
もちろん、単一プロセッサ上ですので、見ているときに動いている唯一のプロセスはUIプロセスです。他のすべてのプロセスは、何らかのイベントを待っています。
%:===> Process browser context menu is broken!
\on{broken -- to be fixed!}
デフォルトでは、プロセスの表示は静止していますが、\actclick{ing} で \menu{turn on auto-update(a)} を選ぶことで更新することができます。

左上のペインでプロセスを選ぶと、ちょうど、デバッガのように、右上のペインにそのプロセスのスタックトレースが表示されます。
スタックトレースを選ぶと、対応するメソッドが下部のペインに表示されます。
プロセスブラウザは \self や \lct{thisContext} のためのミニインスペクタを備えてはいませんが、スタックトレース上で \actclick{ing} することにより同様の機能を提供します。

%=========================================================
\section{メソッド検索}
\seclabel{methodFinder}

\pharo にはメソッド検索のための二つのツールがあります。
両者はインターフェースも機能性も異なっています。

\emph{メソッド・ファインダ}は \secref{quick:methodFinder} である程度説明したように、メソッドを名前や機能性から探すことができます。
しかし、メソッドの本体を見ようとすると、メソッド・ファインダは新たにブラウザを開いてしまいます。
これではすぐにウィンドウで溢れてしまいます。

\begin{figure}[btp]
\begin{center}
\ifluluelse
{\includegraphics[width=\textwidth]{methodNamesRandom}}
{\includegraphics[width=0.7\textwidth]{methodNamesRandom}}
\end{center}
\caption{\ct{random} を部分文字列としてセレクタ名に持つすべてのメソッドを表示しているメッセージネームブラウザ}
\figlabel{methodNamesRandom} % should be *message* names!
\end{figure}

\index{message names browser}
\emph{メッセージネームブラウザ} は、より限定的な検索機能を持っています。検索用の入力欄にメッセージ・セレクタの一部を入力すると、\figref{methodNamesRandom} のように、名前にその一部を含んだすべてのメソッドがブラウザに表示されます。
さらに、これは一人前のブラウザでもあります。
左側のペインにある名前の一つを選択すると、その名前を持つすべてのメソッドが右側のペインに表示され、下部のペインでブラウズできます。
ブラウザと同様に、メッセージネームブラウザはボタン・バーを備えており、選択したメソッドやそのクラスを他のブラウザで開くことができます。


% section methodFinder (end)

%=========================================================
\section{チェンジセットとチェンジソーター}
\seclabel{env:changeSet} % (fold)

\pharo で作業をしている間、メソッドやクラスに対するどのような変更も \lct{チェンジセット} に記録されます。
新しいクラスを作成したこと、クラス名を変更したこと、カテゴリを変更したこと、既存のクラスにメソッドを追加したことなど\,---\,重要な変更はすべて記録されます。
しかし、きままな \emph{doit} は含まれないので、例えばワークスペースで新しくグローバル変数を定義した場合には、変数の作成は\subind{file}{チェンジセット}に記録されません。
\index{change sorter}

多くのチェンジセットが存在していますが、常にそのうちの一つだけがイメージに対する変更を収集します。\,---\,これを \lct{カレントチェンジセット} と呼びます\,---\,
\menu{World \go Tools \ldots \go Change Sorter}を選ぶと現れるチェンジソーターを使えば、どれがカレントチェンジセットなのか確認したり、すべてのチェンジセットについて調べたりすることができます。

\begin{figure}[btp]
\begin{center}
\includegraphics[width=\linewidth]{changeSorter}
\end{center}
\caption{チェンジソーター}
\figlabel{changeSorter}
\end{figure}

\figref{changeSorter} にチェンジソーターを示します。タイトルバーは、どのチェンジセットがカレントチェンジセットなのかを表すとともに、カレントチェンジセットが選択された状態でチェンジソーターが開きます。

左上のペインで他のチェンジセットを選ぶことができます。\actclick メニューで他のチェンジセットをカレントチェンジセットにしたり、新しいチェンジセットを作ったりすることができます。
右隣のペインには、選択したチェンジセット(とそのカテゴリ)が影響を与えるすべてのクラスがリスト表示されます。
クラスの一つを選ぶと、(クラスのすべてのメソッド \emph{ではなく})そのチェンジセットに存在するメソッドの名前が左中央のペインに表示され、さらにメソッド名を選ぶと下のペインにメソッドの定義が表示されます。
チェンジソーターは、クラスの生成自体がチェンジセットの一部であるかどうかを\emph{示さない}ことに注意してください。なお、クラス生成に関する情報は、チェンジセットを表現するためのオブジェクト構造には格納されています。

チェンジソーターでは、クラスやメソッドの上で \actclick メニューを使うことで、チェンジセットから削除することができます。
% However, for more elaborate editing of change sets, you should use a second tool, the \textit{change sorter}, available by selecting \menu{World\go{}open \ldots \go{}dual change sorter}, which is shown in \figref{changeSorter}.
% The change sorter is essentially two change set browsers side by side; each side can focus on a different change set, class, or method.

チェンジソーターは、同時に二つのチェンジセットを扱え、一つは左側でもう一つは右側に表示されます。
この配置により、チェンジソーターの主な特徴である、一方のチェンジセットからもう一方へと変更の移動やコピーが支援されます。\figref{changeSorter}に \actclick メニューを示します。
個々のメソッドを一方からもう一方へコピーすることもできます。

なぜ、チェンジセットの合成に注意を払わなければならないのか、不思議に思うかもしれません。
その答えは、チェンジセットが \pharo からファイルシステムにコードを書き出すシンプルな仕組みを提供するからです。つまり、コードを他の \pharo イメージに取り込んだり、\pharo 以外の \st に取り込んだりすることができるからです。
チェンジセットの書き出しは ``ファイルアウト'' として知られているもので、どんなチェンジセットでも、どんなブラウザのクラスやメソッドでも、\actclick メニューにより行うことができます。
ファイルアウトを繰り返すと、ファイルの新しいバージョンが生成されますが、
チェンジセットは Monticello のようなバージョン管理ツールではないので、依存関係の追跡は行いません。
\index{file!filing out}

Monticello の出現以前、チェンジセットは Smalltalker の間でコードを交換する主な手段でした。
チェンジセットは、単純さ(ファイルアウトしたものは単なるテキストファイルですが、テキストエディタで編集するようなことは \emph{お勧めしません} )と可搬性の高さという利点を持っています。
%It's also quite easy to create a change set that makes changes to many different, unrelated parts of the system\,---\,something that Monticello is not yet equipped to do.
%\ab{Or is it?}
%\on{you mean something different than extensions to foreign packages using the *package protocol notation?}

チェンジセットの主な欠点は、\ind{Monticello} パッケージに比べて依存関係の概念をサポートしていないということです。ファイルアウトしたチェンジセットは、読み込まれる際にイメージに変更を加える \emph{アクション} の集合です。チェンジセットを無事に読み込むためには、イメージはふさわしい状態にあることが求められます。
例えば、チェンジセットがあるクラスへメソッドを追加するアクションを含んでいる場合、あらかじめイメージにそのクラスが定義されているときのみ、読み込みを完了できます。
同様にチェンジセットが、クラス名の変更やカテゴリの変更を行う場合も、当然そのクラスがイメージに存在しているときのみ正しく動作します。ファイルアウト時には、クラスに定義されているインスタンス変数をメソッドが参照しているのに、それを取り込もうとしているイメージには変数が存在していないこともあり得ます。
問題は、チェンジセットがファイルインできる条件を明示していないことです。
ファイルインのプロセスはうまくいくことが望まれますが、うまくいかない場合、たいていわけのわからないエラーメッセージとスタックトレースで終わることになります。
たとえファイルインが成功しても、あるチェンジセットが別のチェンジセットによる変更を勝手に元に戻してしまうことすらあります。

これとは対照的に Monticello パッケージではコードを宣言的な流儀で表現します。つまり、読み込みの完了後にイメージがどのような状態であるべきかを記述します。
これにより(二つのパッケージが最後の段階で矛盾した要求を持つ場合など)コンフリクトについて警告し、
依存関係の順序で一連のパッケージをロードすることを提案します。

こういった欠点にも関わらず、チェンジセットは未だに使われています。特にインターネット上では、参考にしたり場合によっては使いたいと思うチェンジセットが見つるかもしれません。
さて、チェンジソーターを使ってチェンジセットをファイルアウトするところを見てきたので、今度はファイルインの方法を説明しましょう。
それには別のツール、ファイルリストブラウザが必要になります。

% section changeSet (end)

%=========================================================
\section{ファイルリストブラウザ}

\begin{figure}[btp]
\begin{center}
\ifluluelse
{\includegraphics[width=\textwidth]{fileList}}
{\includegraphics[width=0.7\textwidth]{fileList}}
\end{center}
\caption{ファイルリストブラウザ}
\figlabel{fileList}
\end{figure}

\ind{ファイルリストブラウザ} は、実際のところ \pharo からファイルシステム(FTPサーバーも含む)をブラウズするための汎用的なツールです。
\menu{World \go{}Tools \dots \go{}File Browser} メニューで開くことができます。
もちろん、みなさんのローカルのファイルシステムの内容次第で見えるものは変わりますが、典型的な見え方を \figref{fileList} に示します。
\seeindex{file!browsing}{file list browser}

最初にファイルリストブラウザを開くと、カレントディレクトリ、つまり \pharo を起動したディレクトリが選択された状態になります。タイトルバーにはこのディレクトリへのパスが表示されます。
左側の大きなペインは、ごく一般的なやり方でファイルシステムをたどるのに使えます。
ディレクトリが選択されると、そのディレクトリ内のファイル(ディレクトリは含まれない\footnote{訳注：実際には表示されます})のリストが右側に表示されます。
このファイルのリストは、Unix流のパターンをウィンドウの左上にある小さな入力ボックスに入力することでフィルタをかけることができます。
最初、このパターンは \ct{*} であり、すべてのファイル名にマッチしますが、異なる文字列を入力してアクセプトすると、パターンが変更されます。(入力したパターンの前後には、暗黙的に \ct{*} が付加されることに気をつけてください）
ファイルの並び順は、\button{name}、\button{date} そして \button{size} ボタンで変更できます。
その他のボタンはブラウザで選択したファイル名に依存します。
\figref{fileList} では、ファイル名のサフィックスが \ct{.cs} であると、ブラウザがチェンジセットだと推測し、\button{install} する（この場合、そのファイル名に基づいた名前のチェンジセットに \textit{ファイルイン} されます）ためのボタンや、ファイルの変更点を見るための \button{changes} ボタン、ファイル内のコードを調べるための \button{code} ボタン、
\emph{カレントチェンジセット} にコードを取り込むための\button{filein} ボタンを提供します。
\button{conflicts} ボタンは、イメージに既にあるコードとコンフリクトするようなチェンジセットの変更を教えてくれるものと推測されるかもしれませんが、それは違います。
\ab{Does anyone know what it does do? I've never found it useful.}
\on{I tried it and found that it complained about linefeeds.}
その代わりに（改行の有無など）ファイルが正しく読み込まれるかといった潜在的な問題をチェックします。

\begin{figure}[btp]
\begin{center}
\ifluluelse
{\includegraphics[width=\textwidth]{fileContentsBrowser}}
{\includegraphics[width=0.7\textwidth]{fileContentsBrowser}}
\end{center}
\caption{ファイルコンテンツブラウザ}
\figlabel{fileContentsBrowser}
\end{figure}

ボタン表示の選択はファイル内容ではなくファイルの \emph{名前} に依存していることから、時折期待するボタンが画面に現れないことがあります。
しかし、すべてのオプションは常に \actclick の \menu{more \ldots} から利用できるので、
簡単にこの問題へ対処できます。

\button{code} ボタンは、おそらくチェンジセットを扱う上で最も便利なもので、チェンジセットファイルの内容をブラウザで開きます。例を \figref{fileContentsBrowser} に示します。
このファイルコンテンツブラウザはブラウザによく似ていますが、クラスとプロトコルとメソッドだけを表示し、カテゴリを表示しません。
個々のクラスごとに、そのクラスが既にシステムに存在しているかどうか、ファイルで定義されているかどうか（定義が \emph{同一か否か}は示しません）がわかるようになっています。
個々のクラスのメソッドを表示した上で、さらに（\figref{fileContentsBrowser} のように）現在のバージョンとファイルのバージョンとの差分を表示します。
上部の4つのペインのコンテキストメニューでは、チェンジセット全体をファイルインするのか、それとも対応するクラスや、プロトコル、メソッドごとにファイルインするかどうかを指示できます。

%=========================================================
\section{Smalltalkでは、コードを失うことはありません}
\seclabel{cantLoseCode} % (fold)

\pharo がクラッシュすることは十分あり得ることです。実験的なシステムであり、\pharo が機能するために必要なものを含め、すべてが変更可能になっているからです！

\dothis{悪意を持って \pharo をクラッシュさせましょう。 \ct{Object become: nil} を試してみてください}

クラッシュしてイメージが何時間も前に保存したバージョンに戻ってしまったとしても、良い知らせがあります。それはみなさんがやったことは決して失われないということです。
というのも、実行したあらゆるコードが \emph{.changes} ファイルに保存されているからです。
あらゆるコードです!
これにはワークスペースで評価した1行プログラムから、プログラミング中にクラスへ追加したコードまで含まれます。
\index{changes}

ここでは、どのようにコードを回復するかという手順を説明します。
必要なときまで、特に読む必要はありませんが、
そうなったときに見つけられるよう、ここでみなさんをお待ちしています。

最悪の場合では、\emph{.changes} ファイルをテキストエディタで開くこともできますが、数メガバイトに達するため遅くなりますし、お勧めできません。
\pharo は、より良い方法を提供します。

%---------------------------------------------------------
\subsection{コードを回復する方法}
最後のスナップショットの \pharo をリスタートして、 \menu{World\go{}Tools \ldots \go{}Recover lost changes} を選びます。
%This will open a workspace full of useful expressions. The first three,

%\begin{code}{}
%Smalltalk recover: 10000.
%ChangeList browseRecentLog.
%ChangeList browseRecent: 2000.
%\end{code}

%\noindent
%are most useful for recovery.

% If you execute \ct{ChangeList browseRecentLog}, you will be given

すると、履歴をどれくらい遡ってブラウズしたいかを選ぶことができます。
通常、最後のスナップショットまで遡って変更をブラウズすることで十分です。（同様の効果を \ct{ChangeList browseRecent: 2000} というコードを編集することで得ることができます。ただし \ct{2000} という数値は試行錯誤で決めることになります）

\emph{recent changes}ブラウザが表示されますが、これは最後のスナップショットの後の変更で、 \pharo に対して行ったすべての操作のリストとなります。
このリストから \actclick メニューで項目を削除することができます。
これで十分と判断したら、残ったものをファイルインできます。このように、新しいイメージに変更を加えます。
ファイルインする前に、普通のチェンジセットブラウザを使って新しいチェンジセットを作るのは良いアイデアです。これによって復元したすべてのコードが新しいチェンジセットの中に入るからです。
その後、チェンジセットをファイルアウトすることができます。

\emph{recent changes} ブラウザの便利な機能に \menu{remove doIts} があります。
たいてい、do itの操作はファイルイン(つまり再実行)したくないでしょう。
しかし、例外もあります。
クラス定義は \menu{doIt} として表現されるからです。
\emph{あるクラスのメソッドをファイルインする前に、クラスは存在していなければなりません。}
そこで、新しいクラスを定義する際には、\emph{最初に}クラスを定義するdo itをファイルインし、その後 \menu{remove doIts} してからメソッドをファイルインします。
\lr{Maybe mention that class renames are not logged and completely screw up the change-set mechanism. (p. 174)}

私がリカバリが完了するときは、新しいチェンジセットをファイルアウトした後、イメージを保存することなく \pharo を終了します。再起動して、きれいな状態に戻ってから新しいチェンジセットを適用するようにしています。
% section cantLoseCode (end)

%=========================================================
\section{まとめ}

\pharo で開発作業を効果的に行うためには、開発環境が提供するツールについて学ぶ努力を惜しまないことが大切です。

\begin{itemize}
  \item 標準的な \emph{ブラウザ} は、既存のカテゴリやクラス、メソッドプロトコルやメソッドを調べたり、新しく定義したりするための中心的なインターフェースです。
    ブラウザは、メッセージのセンダやインプリメンタ、メソッドのバージョンへ直接ジャンプするといった、いろいろな便利なボタンを提供します。
  \item （OmniBrowser やリファクタリングブラウザといった）様々なブラウザや、クラスやメソッドへの様々なビューを提供する（階層ブラウザなど）特殊用途のブラウザがあります。
  \item どんなツールでも、クラスやメソッドの名前を選んだ後に \short{b} のキーボードショートカットを使えば、すぐにブラウザへジャンプできます。
  \item \ct{SystemNavigation default} に対してメッセージを送ることでも、 \st システムをプログラミング的にブラウズできます。
  \item \emph{Monticello} は、クラスやメソッドのパッケージを外部へ出力したり、取り込んだり、バージョン管理や共有するためのツールです。
    Monticello のパッケージは、カテゴリやサブカテゴリと他のカテゴリに属する関連メソッドプロトコルから構成されます。
  \item \emph{インスペクタ} と \emph{エクスプローラ} の二つのツールは、イメージの中で生きているオブジェクトを調べたり対話したりするための便利なツールです。
    \metaclick{すること} によりMorphic Haloを出し、デバッグハンドル \debugHandle を選ぶと、ツールをインスペクトすることもできます。
  \item \emph{デバッガ} は、エラーが起きた際にプログラムの実行スタックを見せるだけでなく、ソースコードを含め、アプリケーションのすべてのオブジェクトと対話することを可能にするツールです。多くの場合、デバッガでソースコードを修正し、実行を継続することが可能です。デバッガはSUnit(\charef{SUnit})と並んでテストファースト開発を支援する効果的なツールです。
  \item \emph{プロセスブラウザ} は、イメージの中で現在実行中のプロセスを監視したり問い合わせたり対話したりできます。
  \item \emph{メソッド・ファインダ} と \emph{メッセージネームブラウザ} は、メソッドの場所を突き止めるツールです。前者は、名前がはっきりわからないが期待される振る舞いがわかってる場合に便利です。後者は、名前の一部しかわからない場合に、ブラウズのための優れたインターフェースを提供します。
  \item \emph{チェンジセット} は、イメージのソースコードに対するすべての変更を自動的に記録されるログのことです。主にソースコードのバージョンの保存や交換の手段としては、Monticello に取って代わられていますが、ごくまれに発生し得る壊滅的な故障からの復旧などでは未だに便利です。
  \item \emph{ファイルリストブラウザ} はファイルシステムをブラウズするツールです。これはファイルシステムからソースコードを \menu{filein} することもできます。
  \item イメージを保存したり Monticello でソースコードをバックアップしたりする前にクラッシュしてしまった場合、\emph{チェンジリストブラウザ} を使うことで最新の変更から回復することができます。再実行したい変更を選んで、最新のイメージのコピーに取り込むことができます。
\end{itemize}

%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================

%=========================================================
%---------------------------------------------------------
